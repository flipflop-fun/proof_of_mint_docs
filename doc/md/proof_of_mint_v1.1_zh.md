# 区块链代币分配的新提案：铸造证明

**作者**：公平启动实验室 (F.L.L.)  
**日期**：2024年11月6日  
**版本**：v1.11  

---

### 摘要

公平铸造（或公平启动）的概念在区块链社区中获得了显著的关注，然而它面临着诸如西比尔攻击、社区共识构建时间不足、欺诈以及缺乏市场价值管理等关键问题。

本文提出了一种新的解决方案——铸造证明（PoM），灵感来源于比特币的挖矿难度机制。PoM 旨在通过将哈希算力转化为铸造参与度来解决公平性问题，从而减轻西比尔攻击的影响，并为社区共识构建提供充足的时间。

提议的 PoM 旨在确保稳定的铸造过程，抑制投机和作弊行为，并激励真实用户。本文详细分析了 PoM 机制，包括计算难度系数和每个 Epoch 铸造规模的核心公式。

本文还展示了模拟测试参数和结果，显示了 PoM 在维持稳定铸造曲线方面的有效性。此外，还讨论了基于 Era、Epoch 和减少因子的总供应量计算，以及预计的总铸造时间。

本文提出了公平铸造范式的重大进步，提供了一种更公平、社区驱动的代币铸造和分配方法。PoM 有望通过确保更公平和可持续的铸造过程，重塑去中心化金融的格局。

## 1 - 问题

在过去两年中，区块链社区中的公平铸造（或公平启动）变得极为流行。许多代币迅速完成了铸造过程，并随后在去中心化交易所上市交易。然而，其价格趋势通常呈现出一种共同模式：初始快速上涨后，价格持续下跌。

通过对各种公平铸造平台和项目的两年观察和研究，我们发现了以下问题：

### 1.1 - 西比尔攻击

根据相关数据，公平铸造游戏中真实参与者的比例高达 90%。然而，超过 95% 的代币由少数精通区块链技术的人铸造。因此，绝大多数普通真实参与者只能获得非常少量的代币。

这种技术方法通常被称为“西比尔攻击”，它剥夺了公平铸造的“公平性”。少数人以极低的成本控制大量代币，通过快速推高代币价格然后高价出售以获取巨额利润，这种行为被称为“拉高出货”。

### 1.2 - 社区共识构建时间不足

社区缺乏足够的时间来构建共识。由于代币铸造速度过快，社区仍在构建过程中时，价格往往开始下跌，导致社区共识瓦解，最终导致社区解散。

### 1.3 - 欺诈

一些项目的成员通过技术手段参与铸造，制造市场“热烈”的虚假印象，获取低成本代币，操纵市场以获得巨额利润，将公平铸造变成欺诈工具。

### 1.4 - 缺乏市场价值管理 (*MVM*)

缺乏有效的市场价值管理措施。鉴于铸造速度极快，通常 100% 的代币在铸造完成后直接进入流通，市场价值管理变得至关重要。然而，公平铸造代币的“无主”特性需要社区自发组织 MVM。不幸的是，由于铸造速度过快，MVM 往往无法在代币价格崩溃前及时实施。

### 1.5 - 流动性管理有效吗？

一些公平铸造平台引入了流动性管理机制，例如在铸造过程中收取一定费用，这些费用被锁定在智能合约中，并在满足特定条件（如达到目标金额或完成所有铸造）后自动添加到去中心化交易所的流动性池中。

然而，我们观察到，在这些项目初始价格快速上涨时，流动性池中的资金占总流动性池的比例非常低；而当价格下跌时，流动性池中的资金远远不足以抵挡抛售。

### 1.6 - 时间锁机制有效吗？

一些智能合约引入了时间锁机制以防止西比尔攻击，这确实可以防止使用同一账户进行批量铸造，但仍然无法阻止使用不同账户进行批量铸造的人。

### 1.7 - 内存池和 *MEV*

大多数区块链基于以太坊 EVM，EVM 的**内存池**允许大量机器人“窥视”用户在新区块打包前的意图，并率先进行链上操作，如铸造和交易。我们观察到，在以太坊（区块打包间隔约 12 秒）和 Arbitrum 等二层网络（区块打包间隔约 0.25 秒）上存在大量此类行为。这种行为被称为**最大可提取价值 (MEV)**。据估计，自 2020 年 1 月 1 日以来，MEV 总额已超过 7.3 亿美元，其中大部分流向了机器人和矿工。MEV 的存在是由技术驱动的，尽管可以理解，但极大地影响了链上操作的公平性。

我们认为，有效防止西比尔攻击等技术手段并为社区共识的建立提供足够时间，已成为最严峻的挑战。尽管许多公平铸造平台已经意识到这一问题的严重性，并尝试采取相应措施防止各种作弊行为，但实际效果相当有限。

为了有效防止西比尔攻击，一些平台或项目采用了**KYC 认证**或依赖项目团队控制的服务器提供**授权签名**，要求铸造者持有该签名才能铸造。然而，这些方法过于中心化，因此难以被加密社区广泛接受和支持。

## 2 - 提案

我们认为，在当前区块链技术下，完全消除这些问题非常困难。然而，一些新机制可以缓解这些问题，增强公平铸造的公平性并建立更好的社区。

本文提出以下解决方案：

### 2.1 - 比特币挖矿难度机制

本提案借鉴了比特币挖矿的难度机制，因此在介绍本提案之前，我们先简要介绍比特币挖矿机制。

比特币挖矿的难度机制是比特币网络的核心组成部分。它确保在去中心化网络中，铸造进度以大约每 10 分钟一个区块的稳定速度进行。该机制设计用于适应不同时间网络哈希算力的变化，旨在无论节点如何加入网络，都保持新区块生成速度的相对稳定。

比特币挖矿难度的调整通过一个自动算法实现，大约每两周（2016 个区块）调整一次。该周期基于比特币网络的目标区块生成时间（每 10 分钟一个区块）设计。如果过去 2016 个区块的平均生成时间少于 10 分钟，难度将增加，以确保未来区块生成时间恢复到 10 分钟。反之，如果平均区块生成时间超过 10 分钟，难度将降低。

难度的具体计算基于前 2016 个区块的生成时间与目标时间（20160 分钟，即两周）的比较。难度调整公式根据实际时间与目标时间的比率增加或减少难度。这种调整是连续的，以确保比特币网络能够适应不断变化的哈希算力，无论矿工加入还是离开，或高算力挖矿硬件参与。

此外，难度的调整还受到最大变化限制的约束，即单次调整的难度不能超过前次难度的 4 倍。这是为了防止难度突然大幅波动对网络造成影响。

随着比特币网络的发展，挖矿难度持续增加，主要是因为参与挖矿的哈希算力不断增长。随着更多矿工加入网络和挖矿硬件技术的改进，挖矿的总算力持续上升，这增加了单个矿工或矿池发现新区块的难度。因此，挖矿难度的增加反映了比特币网络哈希算力的增长，同时也确保比特币的发行速度保持稳定。

比特币挖矿难度机制是比特币网络适应性和稳定性的关键。它通过动态调整难度值，确保比特币区块的生成速度保持在设计的目标水平，同时适应网络哈希算力的变化。

#### 上述难度规则在比特币代码中的关键代码（C++ 版本）

```cpp
/* 计算给定区块索引的难度。
 */
double GetDifficulty(const CBlockIndex& blockindex)
{
    int nShift = (blockindex.nBits >> 24) & 0xff;
    double dDiff =
        (double)0x0000ffff / (double)(blockindex.nBits & 0x00ffffff);

    while (nShift < 29)
    {
        dDiff *= 256.0;
        nShift++;
    }
    while (nShift > 29)
    {
        dDiff /= 256.0;
        nShift--;
    }

    return dDiff;
}
```

[比特币 GitHub 仓库](https://github.com/bitcoin/bitcoin/blob/1dda1892b6bcc3d4f9678960cc9e9920f491e87e/src/rpc/blockchain.cpp#L87C1-L107C2)

```cpp
unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock, 
  const Consensus::Params& params)
{
    assert(pindexLast != nullptr);
    unsigned int nProofOfWorkLimit = UintToArith256(params.powLimit).GetCompact();

    // 仅在难度调整间隔时更改
    if ((pindexLast->nHeight+1) % params.DifficultyAdjustmentInterval() != 0)
    {
        if (params.fPowAllowMinDifficultyBlocks)
        {
            // 测试网的特殊难度规则：
            // 如果新区块的时间戳超过 2*10 分钟
            // 则允许挖掘最小难度区块。
            if (pblock->GetBlockTime() > pindexLast->GetBlockTime() + params.nPowTargetSpacing*2)
                return nProofOfWorkLimit;
            else
            {
                // 返回最后一个非特殊最小难度规则的区块
                const CBlockIndex* pindex = pindexLast;
                while (pindex->pprev && pindex->nHeight % params.DifficultyAdjustmentInterval() 
                  != 0 && pindex->nBits == nProofOfWorkLimit)
                    pindex = pindex->pprev;
                return pindex->nBits;
            }
        }
        return pindexLast->nBits;
    }

    // 回溯到 14 天前的区块
    int nHeightFirst = pindexLast->nHeight - (params.DifficultyAdjustmentInterval()-1);
    assert(nHeightFirst >= 0);
    const CBlockIndex* pindexFirst = pindexLast->GetAncestor(nHeightFirst);
    assert(pindexFirst);

    return CalculateNextWorkRequired(pindexLast, pindexFirst->GetBlockTime(), params);
}
```

[比特币 GitHub 仓库](https://github.com/bitcoin/bitcoin/blob/1dda1892b6bcc3d4f9678960cc9e9920f491e87e/src/pow.cpp#L14)

### 2.2 - 铸造证明（PoM）

如果我们将比特币的哈希计算替换为铸造行为，有效地将哈希算力转化为铸造参与度，我们就得出了我们提出的解决方案，称为**铸造证明**，简称 **PoM**。

假设我们在以太坊上部署 **PoM**，以太坊已更新为**权益证明（PoS）**共识，平均区块时间约为 **12 秒**。为了实现铸造过程的稳定性，我们设计了以下计划：

- 整个铸造过程分为若干个 **Era**，每个 **Era** 包含若干个 **Epoch**。
- 每个 **Epoch** 有一个难度系数（初始 **Epoch** 的难度系数为 **1**），由前一个 **Epoch** 的实际运行时间决定，并决定当前区块的铸造规模。
- 每个 Epoch 有多个铸造实例；同一 Epoch 的每个铸造实例的 **铸造规模** 相同。
- 每个 **Era** 内的 **Epoch** 的 **目标铸造规模** 和 **基础铸造规模** 按照固定的 **减少因子** 减少。
- 每次铸造需要固定费用，该费用不随 **Era** 和 **Epoch** 的铸造规模减少而变化。

### 2.3 - 示例

#### 2.3.1 - 快速铸造

在第 1 个 **Era** 中，**目标铸造规模** 为 **100,000 代币**，**基础铸造规模** 为 **100 代币**，**每个 Epoch 的目标铸造时间** 为 **10 分钟**，铸造费用为 **0.1 ETH**。

假设在第 9 个 **Epoch** 中，**100,000 代币** 在 400 秒内铸造完成，**难度系数** 为 **1.015086348**，第 10 个 **Epoch** 用时 200 秒，那么第 10 个 **Epoch** 的 **难度系数** 将自动增加到 **1.02185359**，**每次铸造的规模** 将自动减少到 **100 / 1.02185359 = 97.86137759 代币**，每代币的成本为 **0.1 ETH / 97.86137759 代币 = 0.001021854 ETH**。

然后，第 11 个 **Epoch** 用时 **1000 分钟**（超过目标时间 600 秒），因此 **难度系数** 将保持与第 10 个 **Epoch** 相同的 **1.02185359**，**每次铸造的规模** 和每代币的成本与第 10 个 **Epoch** 相同。

接着，第 16 个 **Epoch** 的铸造时间变为 **200 秒**，**难度系数** 将自动增加到 **1.028665947**，**每次铸造的规模** 将减少到 **100 / 1.028665947 = 97.213289 代币**，每代币的成本为 **0.1 ETH / 97.213289 代币 = 0.001028666 ETH**，高于之前的 **Epoch**。

以下是解释上述示例的表格：

| Epoch | Epoch 铸造时间 | 难度系数变化 | 难度系数       | 每次铸造规模   | 每代币成本     |
|-------|----------------|--------------|---------------|---------------|---------------|
| 1     | 500            | 0.001666667  | 1.001666667   | 99.83361065   | 0.001001667   |
| 2     | 400            | 0.003333333  | 1.005005556   | 99.50193752   | 0.001005006   |
| 3     | 500            | 0.001666667  | 1.006680565   | 99.3363769    | 0.001006681   |
| 4     | 600            | 0            | 1.006680565   | 99.3363769    | 0.001006681   |
| 5     | 700            | 0            | 1.006680565   | 99.3363769    | 0.001006681   |
| 6     | 800            | 0            | 1.006680565   | 99.3363769    | 0.001006681   |
| 7     | 600            | 0            | 1.006680565   | 99.3363769    | 0.001006681   |
| 8     | 400            | 0.003333333  | 1.010036167   | 99.00635571   | 0.001010036   |
| **9** | 300            | 0.005        | 1.015086348   | 98.51378678   | 0.001015086   |
| **10**| 200            | 0.006666667  | 1.02185359    | 97.86137759   | 0.001021854   |
| **11**| 1000           | 0            | 1.02185359    | 97.86137759   | 0.001021854   |
| 12    | 800            | 0            | 1.02185359    | 97.86137759   | 0.001021854   |
| 13    | 1200           | 0            | 1.02185359    | 97.86137759   | 0.001021854   |
| 14    | 1500           | 0            | 1.02185359    | 97.86137759   | 0.001021854   |
| 15    | 1000           | 0            | 1.02185359    | 97.86137759   | 0.001021854   |
| **16**| 200            | 0.006666667  | 1.028665947   | 97.213289     | 0.001028666   |
| 17    | 800            | 0            | 1.028665947   | 97.213289     | 0.001028666   |
| 18    | 500            | 0.001666667  | 1.03038039    | 97.05153644   | 0.00103038    |
| 19    | 600            | 0            | 1.03038039    | 97.05153644   | 0.00103038    |
| 20    | 500            | 0.001666667  | 1.032097691   | 96.89005302   | 0.001032098   |

上表代代币成本的图表如下：

![代币成本图表](https://live.staticflickr.com/65535/54398767960_dd87762ab5_o.png)

#### 2.3.2 - 按目标时间铸造

如果铸造过快，铸造成本将迅速增加。但如果按目标时间铸造，每个人将获得相同的代币成本。

以下是解释的表格：

| Epoch | Epoch 铸造时间 | 难度系数变化 | 难度系数       | 每次铸造规模   | 每代币成本     |
|-------|----------------|--------------|---------------|---------------|---------------|
| 1     | 589            | 0.000183333  | 1.000183333   | 99.98167003   | 0.001000183   |
| 2     | 609            | 0            | 1.000183333   | 99.98167003   | 0.001000183   |
| 3     | 596            | 6.66667E-05  | 1.000250012   | 99.97500503   | 0.00100025    |
| 4     | 594            | 0.0001       | 1.000350037   | 99.96500853   | 0.00100035    |
| 5     | 607            | 0            | 1.000350037   | 99.96500853   | 0.00100035    |
| 6     | 609            | 0            | 1.000350037   | 99.96500853   | 0.00100035    |
| 7     | 609            | 0            | 1.000350037   | 99.96500853   | 0.00100035    |
| 8     | 608            | 0            | 1.000350037   | 99.96500853   | 0.00100035    |
| 9     | 604            | 0            | 1.000350037   | 99.96500853   | 0.00100035    |
| 10    | 608            | 0            | 1.000350037   | 99.96500853   | 0.00100035    |
| 11    | 608            | 0            | 1.000350037   | 99.96500853   | 0.00100035    |
| 12    | 607            | 0            | 1.000350037   | 99.96500853   | 0.00100035    |
| 13    | 607            | 0            | 1.000350037   | 99.96500853   | 0.00100035    |
| 14    | 605            | 0            | 1.000350037   | 99.96500853   | 0.00100035    |
| 15    | 603            | 0            | 1.000350037   | 99.96500853   | 0.00100035    |
| 16    | 589            | 0.000183333  | 1.000533435   | 99.94668497   | 0.001000533   |
| 17    | 608            | 0            | 1.000533435   | 99.94668497   | 0.001000533   |
| 18    | 590            | 0.000166667  | 1.00070019    | 99.93002996   | 0.0010007     |
| 19    | 603            | 0            | 1.00070019    | 99.93002996   | 0.0010007     |
| 20    | 611            | 0            | 1.00070019    | 99.93002996   | 0.0010007     |

上表代代币成本的图表如下：

![代币成本图表](https://live.staticflickr.com/65535/54398766190_daf48839aa_o.png)

#### 2.3.3 - 关于 Epoch 的基础铸造规模

此外，**Epoch 的基础铸造规模** 逐渐减少。假设 **减少因子** 为 **3/4**：

- 第 1 个 **Era**，**目标铸造规模** 为 **100,000 代币**，**基础铸造规模** 为 **100 代币**。
- 第 2 个 **Era**，**目标铸造规模** 为 **100,000 * 3/4 = 75,000 代币**，**基础铸造规模** 为 **75 代币**。
- 第 3 个 **Era**，**目标铸造规模** 为 **75,000 * 3/4 = 56,250 代币**，**基础铸造规模** 为 **56.25 代币**。
- ...

### 2.4 - 优势

#### 2.4.1 - 优势 1

如果 **机器人** 参与铸造，它们会发现铸造速度越快，获得的代币越少，成本越高。与许多试图阻止 **机器人** 参与铸造的方法相反，本提案不阻止机器人进行批量铸造。然而，高成本和低收益将阻止机器人。

#### 2.4.2 - 优势 2

如果 **机器人** 监控前一个 **Epoch** 的铸造时间来计算下一个 **Epoch** 的难度并评估是否参与，那么所有机器人必须有自己的策略。否则，趋同的策略将导致所有机器人拥挤，导致收益显著下降和成本大幅增加。因为机器人的收益不取决于铸造的“速度”，而更多取决于对其他机器人行为的“猜测”，大大增加了机器人的策略难度。

#### 2.4.3 - 优势 3

采用难度只增加不减少的机制，确保预期铸造成本始终上升。当难度快速增加时，用户不会期待难度下降，要么继续铸造，要么停止铸造。这避免了等待难度下降而导致的铸造停滞。

#### 2.4.4 - 优势 4

随着难度和铸造成本的增加，直到市场认为成本达到合理水平，此时铸造将减缓或停止。此时的铸造成本将成为代币市场价格的锚点。

#### 2.4.5 - 优势 5

从铸造中收集的资金用于去中心化交易所的流动性池。本提案避免了过去一些平台收取的固定铸造费用远远不足以满足市场流动性需求的问题。随着难度的增加，每次铸造的产出将减少，完成目标铸造规模所需的铸造次数将增加，从而提高铸造费用。增加的铸造费用被引导到流动性池中，为市场价值管理提供充足的流动性支持。

#### 2.4.6 - 优势 6

当市场价格下跌时，人们会发现铸造不再具有成本效益，导致铸造活动减缓或停止。低成本供应的增加将减少或停止，避免价格下跌与代币供应持续增加的“死亡螺旋”陷阱。如果新矿工加入，难度和成本将再次上升。

#### 2.4.7 - 优势 7

铸造成本和难度水平完全取决于市场参与，没有中心化控制，在去中心化环境中实现动态平衡。

> **在最大利益原则的驱动下，最终铸造速度将趋向目标设定，达到纳什均衡。**

这种机制有效激励早期参与者，对持续关注的社区成员非常友好，同时对投机者和通过技术手段作弊的人不友好。

> 我们已在以太坊测试网 **Sepolia**（**Solidity**）和 **Solana**（**Rust/Anchor**）开发网上编码了 **PoM** 铸造算法，并将提供前端 **TypeScript** 脚本供社区测试，同时开源 **Python** 语言模拟代码。

## 3 - 计算

### 3.1 - 公式

#### 3.1.1 - 当前 Epoch 的难度系数

- $d$：难度系数
- $d'$：前一个 Epoch 的难度系数
- $\delta d$：难度系数变化
- $N_e$：已过去 Epoch 的区块数
- $N_t$：每个 Epoch 的目标区块数

难度系数的变化基于实际时间与目标时间的比率计算。我们仅考虑已过去区块数高于每个 Epoch 目标区块数的情况。公式如下：

$$
\delta d = \frac{1 - \frac{N_e}{N_t}}{100}, \quad (N_e < N_t)
$$

$$
\delta d = 0, \quad (N_e \geq N_t)
$$

**注**：在上述公式中，100 是一个用于控制难度增加比例在一定阈值范围内的因子。将此值设为 100 表示难度增加的最大比例为 1%。如果将此值设为 50，则难度增加的最大比例为 2%。

在得到难度系数变化后，当前 Epoch 的难度系数为：

$$
d = d' \cdot (1 + \delta d)
$$

对于可以精确获取区块时间戳的区块链，上述 **区块数** 可以替换为 **时间戳**。

**示例：**

在 2.3.1 的示例中，每个 **Epoch** 的目标铸造时间为 600 秒。在 **第 10 个 Epoch**，铸造用时 200 秒，**第 9 个 Epoch** 的 **难度系数** 为 **1.015086348**，因此 **第 10 个 Epoch** 的新 **难度系数** 将调整为：**1.015086348 * ((1 - 200 / 600) / 100 + 1) = 1.02185359**。

在 **第 11 个 Epoch**，铸造用时 1000 秒，超过目标铸造时间 600 秒，则保持与 **第 10 个 Epoch** 相同的 **难度系数** **1.02185359**。

#### 3.1.2 - 当前 Era 的每次铸造基础规模 ($M_b$)

- $M_b$：当前 Era 的每次铸造基础规模
- $M_0$：创世 Era 的每次铸造基础规模
- $f$：减少因子
- $e$：当前 Era

$$
M_b = M_0 \cdot f^{e-1}
$$

**减少因子**

- $f$=0.5 表示每个 Era 减少 **50%**（减半）
- $f$=2/3 表示每个 Era 减少 **33.33%**
- $f$=3/4 表示每个 Era 减少 **25%**
- $f$=4/5 表示每个 Era 减少 **20%**
- $f$=5/6 表示每个 Era 减少 **1/6**，等等。

#### 3.1.3 - 当前 Era 的每个 Epoch 目标铸造规模

- $T$：当前 Era 的每个 Epoch 目标铸造规模
- $T_0$：创世 Era 的每个 Epoch 目标铸造规模
- $f$：减少因子
- $e$：当前 Era

$$
T = T_0 \cdot f^{e-1}
$$

#### 3.1.4 - 当前 Epoch 的每次铸造规模

- $M$：当前 Epoch 的每次铸造规模
- $M_b$：当前 Era 的每次铸造基础规模
- $d$：难度系数

$$
M = \frac{M_b}{d}
$$

**示例：**

在 2.3.1 的示例中，当前 Era 的 **每次铸造基础规模** 为 **100 代币**，**第 16 个 Epoch** 的 **难度系数** 为 **1.028665947**，则铸造规模为：**100 / 1.028665947 = 97.213289 代币**。

#### 3.1.5

如果 $T$ 不是 $M$ 的整数倍，需要调整 $M$，即：

$$
M_a = \frac{T}{\lfloor \frac{T}{M} \rfloor + 1}, \quad (T \nmid M)
$$

如果 $T$ 是 $M$ 的整数倍，则无需如上调整：

$$
M_a = M, \quad (T \mid M)
$$

#### 3.1.6 - 代币成本

虽然每次铸造的成本保持不变，但随着难度的增加，每次铸造获得的代币数量将减少，因此代币成本将增加。

以下是代币成本的计算方法：

- $P_0$：铸造费用
- $p$：代币成本

$$
p = \frac{P_0}{M_a}
$$

如果 **T** 不是 **M** 的整数倍，价格为：

$$
p = \frac{P_0 \cdot (\lfloor \frac{T_0}{M_0} \cdot d \rfloor + 1)}{T_0 \cdot f^{e-1}}, \quad (T \nmid M)
$$

$$
p = \frac{P_0}{M_0 \cdot f^{e-1}} \cdot d, \quad (T \mid M)
$$

由于 $P_0$、$T_0$、$M_0$、$f$ 和 $e$ 在一个 Era 中是常数，我们知道：$p \propto d$。

#### 3.1.7

$T$ 和 $M$ 在每个 **Era** 中呈指数减少，但两者之间的比率保持不变，无论在哪个 **Era**。

$$
T = T_0 \cdot f^{e-1}
$$

$$
M = \frac{M_b}{d} = \frac{M_0 \cdot f^{e-1}}{d}
$$

$$
\frac{T}{M} = \frac{T_0}{M_0} \cdot d
$$

#### 3.1.8

如果 $N_t$ 设定为 10 分钟，则每次铸造的理论目标间隔时间为：600 秒 / 33 = 18.18 秒/次。

如果间隔时间较长，意味着完成一个 **Epoch** 的所有铸造用时超过计划（10 分钟），这表明矿工较少，此时难度降低，每次铸造的奖励增加。

反之，如果间隔时间较短，表明完成一个 **Epoch** 的铸造用时少于计划（10 分钟），这表明矿工较多，此时难度增加，每次铸造的奖励减少。

### 3.2 - 计算 Epoch 铸造规模的关键代码（Rust）

```rust
pub fn get_mint_size(
  config_data: &TokenConfigData,
) -> Result<(u64, f64, u64)> {
  let delta_difficulty_coefficient = if config_data.mint_state_data.elapsed_seconds_epoch
    < config_data.target_seconds_per_epoch {
    (1.0 - config_data.mint_state_data.elapsed_seconds_epoch.safe_as_f64()? / 
       config_data.target_seconds_per_epoch.safe_as_f64()?) / 100.0
  } else {
    0.0
  };
  let difficulty_coefficient = config_data.mint_state_data.difficulty_coefficient_epoch 
    * (1.0 + delta_difficulty_coefficient);
  let base_mint_size = config_data.initial_mint_size.safe_as_f64()? 
    * config_data.reduce_ratio.powf((config_data.mint_state_data.current_era - 1).safe_as_f64()?);
  let base_target_mint_size_per_epoch = config_data.initial_target_mint_size_per_epoch.safe_as_f64()? 
    * config_data.reduce_ratio.powf((config_data.mint_state_data.current_era - 1).safe_as_f64()?);
  let mint_size =  base_mint_size / difficulty_coefficient;
  let target_mint_size_epoch = (base_target_mint_size_per_epoch / mint_size).trunc() 
  * mint_size;
  Ok((mint_size.safe_as_u64()?, difficulty_coefficient, target_mint_size_epoch.safe_as_u64()?))
}
```

## 4 - 部署参数

### 4.1 - 总供应量

与普通代币发行模式不同，**PoM** 的 **总供应量** 基于 **Era**、**Epoch** 和 **减少因子** 计算。

决定总供应量的四个参数：

- $E$：总 Era 数
- $C$：每个 Era 的初始 Epoch 数
- $T_0$：每个 Epoch 的初始目标铸造规模
- $f$：Era 的减少因子，$f \in (0,1)$

**计算**

$$
TotalSupply = \sum_{i=1}^{E} (C \cdot T_0 \cdot f^{i-1}) = C \cdot T_0 \cdot \frac{1 - f^E}{1 - f}
$$

**示例：**

$E=15$，$C=10$，$T_0=100,000$ 代币，$f=0.75$

**总供应量为：** 3,946,546.156 代币

[点击此处打开 Wolfram 计算](https://www.wolframalpha.com/input?i=sum+10*100000*0.75%5E%28i-1%29%2C+i+%3D+1+to+15)，您可以使用 **Wolfram** 轻松计算总供应量。

#### 4.1.1 - 最大总供应量

当 $E$ 趋向无穷大，即铸造可以无限期继续，**总供应量** 将收敛到一个值，即：

**计算**

$$
\lim_{E \to \infty} \left( C \cdot T_0 \cdot \frac{1 - f^E}{1 - f} \right) = C \cdot T_0 \cdot \frac{1 - f^{\infty}}{1 - f} = \frac{C \cdot T_0}{1 - f}
$$

**示例：**

$C=10$，$T_0=100,000$ 代币，$f=0.75$

**总供应量为：** 4,000,000 代币

### 4.2 - 预计总铸造时间

**注：** 实际总铸造时间将与预计总铸造时间不同。

以下是计算预计总铸造时间的公式：

- $E$：Era 数
- $C$：每个 Era 的 Epoch 数
- $N_t$：每个 Epoch 的目标区块数
- $t$：每个区块的秒数

**计算**

$$
TotalEstimatedTime = E \cdot C \cdot N_t \cdot t
$$

**示例：**

$E=15$，$C=10$，$N_t=50$，$t=12$ 秒

**预计总铸造时间：** $15 \cdot 10 \cdot 50 \cdot 12 = 90,000$ 秒 = 25 小时

### 4.3 - 总 Era 数

结合上述两个公式，我们可以计算当铸造了总供应量 ($r$) 的 80% 时，$E_r$（总 Era 数）的值。

$$
C \cdot T_0 \cdot \frac{1 - f^{E_r}}{1 - f} = \frac{C \cdot T_0}{1 - f} \cdot r
$$

由此得出：

$$
E_r = \log_f(1 - r)
$$

**示例：**

$r=80\%$，$f=0.75$，则 $E_r = \log_{0.75}(1-0.8) = \frac{\ln 0.2}{\ln 0.75} = 5.59$。

这意味着在第 6 个 Era 中期，80% 的总供应量将被铸造。

如果 $C=10$，在第 56 个 Epoch（$5.59 \cdot 10$）时，80% 的总供应量将被铸造。

### 4.4 - 总铸造费用

每次铸造需要固定费用；然而，由于难度的增加，同一 Epoch 内的铸造次数将增加，每次铸造获得的代币数量将减少，因此总费用将相应增加。

> **注：** 这些铸造费用将自动添加到流动性池中。

- $Fee$：总费用
- $P_0$：每次铸造费用
- $d$：难度系数
- $Q$：一个 Epoch 内的铸造次数
- $T_0$：创世 Era 的每个 Epoch 目标铸造规模
- $M_0$：创世 Era 的每次铸造基础规模
- $C_e$：已过去的 Epoch 数，$C_e = E \cdot C$

一个 Epoch 内的铸造次数：

$$
Q = \lfloor \frac{T_0}{M_0} \cdot d \rfloor + 1, \quad (T_0 \nmid M_0)
$$

$$
Q = \frac{T_0}{M_0} \cdot d, \quad (T_0 \mid M_0)
$$

为简单起见，假设 $T_0 \mid M_0$，总费用为：

$$
TotalFee = \sum_{i=1}^{C_e} (P_0 \cdot Q_i) = \sum_{i=1}^{C_e} \left( \frac{P_0 \cdot T_0}{M_0} \cdot d_i \right)
$$

由于 $d_i = d_{i-1} \cdot (1 + \delta d_i)$，$\delta d \in [0,0.01]$（见 3.1.1），且 $d_0=1$，总费用范围为：

$$
TotalFee \in \left[ \frac{P_0 \cdot T_0}{M_0} \cdot \sum_{i=1}^{C_e} 1^i, \frac{P_0 \cdot T_0}{M_0} \cdot 101 \cdot (1.01^{C_e} - 1) \right]
$$

简化后：

$$
TotalFee \in \left[ \frac{P_0 \cdot T_0}{M_0} \cdot C_e, \frac{P_0 \cdot T_0}{M_0} \cdot 101 \cdot (1.01^{C_e} - 1) \right]
$$

**示例**

$P_0=1$ 美元，$T_0=9000$，$M_0=100$，$d=1.5$，$C_e=300$，最低总费用为 27,000 美元，最高为 169,096.2 美元。

这表明如果铸造很快完成，一个 Epoch 的实际铸造时间 ($N_e$) 小于目标时间 ($N_t$)，将导致难度和铸造成本持续增加。因此，收集的总费用将是难度保持不变时的 **6.3** 倍，并且随着 Epoch 数量的增加，差异会更显著。

### 4.5 - 使用案例

#### 4.5.1

如果目标总供应量为 2100 万（大约），可以有（但不限于）以下参数组合：

| $C$  | $T_0$ | $M_0$ | $f$  | $N_t$ | $t$ | 总供应量       | Era 数 | Epoch 数 | 天数    | 总费用（最低） | 总费用（最高） |
|------|-------|-------|------|-------|-----|---------------|--------|---------|---------|---------------|---------------|
| 600  | 9000  | 1000  | 0.75 | 2000  | 12  | 2160 万       | 10.413 | 6248    | 1735.56 | 56,241        | 9.088e29      |
| 500  | 11000 | 1000  | 0.75 | 500   | 12  | 2200 万       | 10.413 | 5206    | 361.57  | 57,277        | 3.49e25       |
| 2500 | 1000  | 100   | 0.75 | 1000  | 0.4 | 1000 万       | 10.413 | 26032   | 120.5   | 260,320       | 3.15e115      |

**注：**

- $Eras = \log_f(1-0.95)$，铸造率为 95%
- $Epochs = Eras \cdot C$
- $days = Epochs \cdot N_t \cdot t / 3600 / 24 = \log_f(1-0.95) \cdot C \cdot N_t \cdot t / 86400$
- 由于 $f$ 和 $t$ 是固定的，总天数取决于 $C$ 和 $N_t$

#### 4.5.2 - 如何计算所有参数

我们将根据以下条件尝试计算所有参数：

- 总供应量：10,000,000
- 总铸造天数：180 天，铸造 95% 的总供应量
- 目标铸造费用：30,000 美元
- $f = 0.75$
- $T_0 = 10,000$
- $M_0 = 1,000$
- $t = 0.4$ 秒（适用于 Solana 区块链）

**计算**

1. $\because TotalSupply = C \cdot T_0 / (1-f)$，所以每个 Era 的初始 Epoch 数 ($C$) 为：

   $C = TotalSupply \cdot (1 - f) / T_0 = 10,000,000 \cdot (1 - 0.75) / 10000 = 250$

2. 根据以下公式，我们可以得到 $N_t = 14935$：

   $C \cdot N_t \cdot t \cdot \log_f(1-0.95) = 180 \text{ 天} \cdot 86400 \text{ 秒/天}$

3. 根据以下公式，我们可以得到 $C_e = 2603$：

   $C_e = Eras \cdot C = \log_f(1-0.95) \cdot C = 10.413 \cdot 250 = 2603$

4. 我们已知：$T_0=10,000$，$C_e=2603$，$M_0=1000$，最低总费用公式：

   $\frac{P_0 \cdot T_0 \cdot (C_e+1)}{M_0} = P_0 \cdot 10,000 \cdot 2604 / 1000 = 300,000$

   根据最低总费用公式，我们可以得到 $P_0 = 11.52$ 美元，这意味着每个代币的最低价格为 $P_0 / M_0 = 11.52 / 1000 = 0.01152$ 美元。

[点击此处打开在线计算器](https://docs.google.com/spreadsheets/d/1z4eO1k14noxTMcgADMc-I0xFXT0giMFPSBEGal4suvI/edit?usp=sharing)

## 5 - 测试和评估

以下是模拟测试的参数：

- 铸造间隔时间范围：0-30 秒随机
- 总 Era 数：10
- 每个 Era 的 Epoch 数：20
- 最低难度系数：0.2
- 减少因子：3/4
- 创世 Era 的每次铸造基础规模：50
- 创世 Era 的每个 Epoch 目标铸造规模：200

### 铸造奖励

![铸造奖励](https://live.staticflickr.com/65535/54398908259_4b136d9be7_o.png)

**Epoch 实际铸造收益 vs. 目标铸造收益**

橙色线条为 **当前 Epoch 的实际铸造规模**，蓝色线条表示 **每次铸造的目标铸造规模**，显示每个 Era 减少 25% 的趋势。

![Epoch 收益](https://live.staticflickr.com/65535/54398911094_519ec5b9c3_o.png)

**实际铸造奖励 vs. 目标铸造奖励**

橙色线条为 **实际铸造规模**，蓝色线条为 **目标铸造规模**。

![铸造奖励](https://live.staticflickr.com/65535/54398738141_fc8789af01_o.png)

**总铸造曲线**

![总铸造曲线](https://live.staticflickr.com/65535/54094891458_1a1e5df73a_o.png)

**以太坊链上的模拟结果**

以上是以太坊链上的模拟结果。

## 6 - 联盟铸造计划

### 6.1 - 描述

**联盟铸造计划**（**AMP**）允许每个用户生成一个 **唯一推荐码**（**URC**）并与他人分享。当他人使用此 **URC** 进行铸造时，他们可以获得铸造费用的折扣，推荐人也可以获得一些奖励。**AMP** 设计为去中心化和社区驱动，激励构建更好的社区。

1. **去中心化和社区驱动**
   - 所有铸造必须使用 **URC**，因此每次铸造都与社区成员相关联。
   - 铸造的进度和速度受社区成员分享 **URC** 的影响，而不是核心团队或一些大户。
   - 通过 **AMP**，社区可以更容易形成共识并吸引更多成员参与。
2. **激励社区**
   - 双重激励：推荐人（代码分享者）和使用 **URC** 的用户（铸造者）均可受益，这种双重激励机制有助于社区的增长和活跃。
3. **铸造折扣和推荐人奖励**
   - 铸造费用折扣与提供 **URC** 的账户代币余额挂钩。推荐人的余额越多，铸造折扣越高，铸造费用越低。这鼓励参与者持有更多代币而不是全部出售。
   - **URC** 分享者可以获得稳定的奖励；这些奖励在铸造发生时由链上货币（以太坊的 ETH 或 Solana 的 SOL）自动分配到推荐人账户。
4. **铸造费用和难度调整**
   - 动态难度：铸造的总成本和难度将根据社区动态调整；参与铸造的人越多，铸造速度越快，总铸造成本越高，额外铸造费用也越高。
   - 部分铸造费用作为折扣重新分配给铸造者，作为奖励分配给 **URC** 分享者。

$$
ExtraMintFee = \frac{P_0 \cdot T_0}{M_0} \cdot (\sum_{i=0}^{C_e} d_i - C_e - 1)
$$

该公式表明，$d_i$ 越高（大约高于 1），额外铸造费用越高。

由于铸造费用进入流动性池以支持市场交易，**AMP** 将对社区发展和代币交易产生积极影响。

### 6.2 - 计算

#### 6.2.1 - 铸造折扣

折扣由代码分享者的余额与 **当前** 总供应量的比率决定。

- $r$：代码分享者余额与 **当前** 总供应量的比率。
- $k$：折扣率。

| $r$      | $k$ |
|----------|-----|
| < 0.2%   | 0   |
| 0.2-0.4% | 5%  |
| 0.4-0.6% | 10% |
| 0.6-0.8% | 15% |
| 0.8-1%   | 20% |
| > 1%     | 25% |

#### 6.2.2 - 折扣后的铸造费用

- $Fee$：折扣后的铸造费用
- $P_0$：原始铸造费用
- $p_0$：第一个 Epoch 铸造代币的价格
- $p$：折扣前的铸造代币价格
- $d$：难度系数
- $k$：折扣率

$$
\frac{Fee}{M_b} \cdot d = p_0 + (p - p_0) \cdot (1 - k) = p \cdot (1 - k) + p_0 \cdot k
$$

$$
p = \frac{P_0}{M_b} \cdot d, \quad p_0 = \frac{P_0}{M_b}
$$

从上述等价公式中，我们可以得到折扣后的铸造费用：

$$
Fee = P_0 \cdot \left(1 + \frac{k}{d} - k\right), \quad (d \geq 1, k \leq 0.25)
$$

$Fee$ 与原始 $P_0$ 的余额为：

$$
P_0 - Fee = P_0 - P_0 \cdot \left(1 + \frac{k}{d} - k\right) = P_0 \cdot k \cdot \left(1 - \frac{1}{d}\right)
$$

折扣率为：

$$
\frac{P_0 - Fee}{P_0} = k \cdot \left(1 - \frac{1}{d}\right)
$$

**示例：**

$P_0=8$ 美元，$d=12.3$，$Token Balance=26,000$，$Total Supply = 5,000,000$ 美元

代币占总供应量的比率 ($r$) = $26,000 / 5,000,000 = 0.52\%$，因此折扣 ($k$) 为 10%。

实际铸造费用为：$8 \cdot (1 + 0.1 / 12.3 - 0.1) = 7.265$ 美元

与原始铸造费用相比，折扣为：$1 - 7.265 / 8 = 9.19\%$

#### 6.2.3 - 唯一推荐码 (URC)

唯一推荐码 (URC) 是由分享者的账户和时间戳生成的唯一代码。

#### 6.2.4 - 铸造码的限制

- 代码的使用次数并非无限制，默认为 50 次。这意味着在使用该代码进行 **50** 次铸造后，代码将失效，分享者需要重新激活。
- 代码分享者不能随时重新激活代码；每次激活之间有间隔时间。默认间隔为 **24 小时**。

#### 6.2.5 - 代码分享者的收益

代码分享者可以获得铸造者节省的余额费用的 20%。

$$
CodeSharerReward = 0.2 \cdot (P_0 - Fee) = 0.2 \cdot P_0 \cdot k \cdot \left(1 - \frac{1}{d}\right)
$$

难度越高，$k$ 越大，代码分享者的收益越大。

**示例：**

根据前述示例，代码分享者的奖励为：

$0.2 \cdot 8 \cdot 0.10 \cdot (1 - 1/12.3) = 0.147$ 美元

### 6.3 - 评估

让我们对铸造费用的公式进行一些更改，看看它如何影响费用：

$$
\frac{MintFee}{P_0} = 1 + \frac{k}{d} - k, \quad (d \geq 1, k \leq 0.25)
$$

#### 6.3.1 - 难度 ($d$) 对铸造费用的影响

根据铸造费用的公式，难度越高，铸造费用越低，折扣越多。

#### 6.3.2 - $k$ 对铸造费用的影响

根据铸造费用的公式，$k$ 越高，铸造费用越低，折扣越多。

#### 6.3.3 - 风险

我们必须考虑一种情况，即 **AMP** 可能会导致自我铸造（使用自己的 **URC** 进行铸造），但我们相信：一旦一个人拥有一定数量的代币，他们会更倾向于建立社区并与他人分享代码。

此外，即使每个人都使用最大折扣进行铸造（这是不可能的），最低总铸造费用将如下：

$$
CodeSharerReward = 0.2 \cdot (P_0 - Fee) = 0.2 \cdot P_0 \cdot k \cdot \left(1 - \frac{1}{d}\right)
$$

因为 $max(k) = 25\%$，当 $d = \infty$ 时，代码分享者获得 $P_0$ 的 5%。

因此，最低总铸造费用为计划的 95%。考虑到 **AMP** 可能带来的社区活跃度，以及难度的增加会提高铸造费用，这种减少是值得的。

### 6.4 - 初始化

#### 6.4.1 - 系统推荐人

为什么需要系统/默认推荐人？

所有铸造都需要 **URC**。如果有人无法从社区成员处获得 **URC**，可以使用系统提供的默认 **URC**。

使用默认 **URC** 时，没有折扣（因为默认推荐人的账户余额为 0）。

### 6.5 - 程序实现

```rust
// 计算费用值和推荐人奖励
pub fn get_fee_value(fee_rate: u64, difficulty_coefficient: f64, referrer_ata_balance: 
  u64, total_supply: f64) -> (f64, f64) {
  let balance_ratio = referrer_ata_balance as f64 / total_supply;
  let discount_rate = if balance_ratio < 0.002 {0.0}
  else if balance_ratio < 0.004 {0.05}
  else if balance_ratio < 0.006 {0.1}
  else if balance_ratio < 0.008 {0.15}
  else if balance_ratio < 0.01 {0.2}
  else {0.25};
  let fee = fee_rate as f64 * (1.0 + discount_rate / difficulty_coefficient - 
    discount_rate);
  let code_sharer_reward = 0.2 * fee_rate as f64 * discount_rate * (1.0 - 1.0 / 
    difficulty_coefficient);
  (fee as f64, code_sharer_reward)
}
```

### 6.6 - URC 生成和验证工作流程

为避免机器人监控 URC 代码的生成和更新以进行抢跑，前端与区块链之间仅交换 **URC_Pubkey**。

以下是 Solana 区块链上的 URC 生成和验证工作流程：

![URC 工作流程](https://live.staticflickr.com/65535/54180284230_abee944341_o.png)

## 7 - 流动性

铸造费用最终将注入去中心化交易所的流动性池，交易费用可在此赚取。

### 7.1 - 流动性池的代币

总代币供应量的一部分将分配到流动性池作为 SOL/代币对。此分配在铸造期间分布到一个专门的流动性账户。一旦满足特定条件（例如，第 1 个 Era 完成），这些代币连同交易费用（SOL）将自动添加到流动性池中。

- $M_a$：每次铸造的代币数量（见 3.1.4, 3.1.5）
- $r_l$：初始流动性池相对于总发行量的比例，$r_l < 1$
- $L$：每次铸造事件进入流动性专用账户的代币数量

$$
L = \frac{M_a \cdot r_l}{1 - r_l}
$$

由于代币的总供应量为：

$$
TotalSupply = \sum_{i=1}^{E} (C \cdot T_0 \cdot \frac{1-f^E}{1-f}) = C \cdot T_0 \cdot \frac{1-f^E}{1-f}
$$

用于初始化流动性池的代币为：

$$
InitLiquidity = TotalSupply \cdot \frac{r_l}{1-r_l} = C \cdot T_0 \cdot r_l \cdot \frac{1-f^E}{(1-f) \cdot (1-r_l)}
$$

### 7.2 - 铸造费用

铸造费用在 6.2.2 节中描述。铸造费用的分配如下：

- URC 提供者：0-5%
- 协议费用：5%
- 流动性池：90-95%

### 7.3 - 初始化流动性池时的预计价格

根据去中心化交易所的 **AMM**，初始化流动性池时的代币价格为：

$$
Price = \frac{0.90 \cdot TotalFee}{InitLiquidity}
$$

由于总铸造费用是一个范围：

$$
TotalFee \in \left[ \frac{P_0 \cdot T_0}{M_0} \cdot C_e, \frac{P_0 \cdot T_0}{M_0} \cdot 101 \cdot (1.01^{C_e} - 1) \right]
$$

因此，初始化流动性池时的最低价格为：

$$
P_{low} = \frac{P_0 \cdot C_e \cdot (1-r_l)(1-f)}{M_0 \cdot C \cdot r_l \cdot (1-f^E)} \cdot 0.90
$$

最高价格为：

$$
P_{high} = \frac{101 \cdot P_0 \cdot (1.01^{C_e} - 1)(1-r_l)(1-f)}{M_0 \cdot C \cdot r_l \cdot (1-f^E)} \cdot 0.90 = \frac{101 \cdot (1.01^{C_e} - 1)}{C_e} \cdot P_{low}
$$

在上述公式中，$C_e = E \cdot C$（$C$ 为每个 Era 的 Epoch 数，$E$ 为 Era 数）。

## 8 - 退款

铸造证明（PoM）是一种根据时间动态调整铸造规模的新代币发行模型。其关键逻辑如下：

- **动态成本调整**：
  - 当实际铸造时间 **短于目标铸造时间** 时，铸造规模减少，代币成本增加。
  - 当实际铸造时间 **等于或长于目标铸造时间** 时，铸造数量和代币成本保持不变。
- **激励机制**：
  - 该机制通过成本增加激励早期参与者，推动铸造活动。
  - 然而，它也可能导致后期参与者的成本过高，影响公平性。

### 8.1 - 退款机制的引入和设计

为解决上述问题，PoM 引入了 **退款** 作为辅助约束，以确保公平性并保护参与者。其关键点如下：

#### 8.1.1 - 目标 Era 锁定

在目标 Era 期间，所有筹集的铸造费用都被锁定在一个特殊金库中，参与者可以随时发起退款。

#### 8.1.2 - 代币数量验证

退款时，系统会验证用户钱包中的代币总量是否等于铸造时的数量。

如果用户已转移或交易部分代币，除非在钱包中补充相应数量的代币，否则退款将失败。

#### 8.1.3 - 费用扣除规则

退款时，将扣除部分货币（例如 ETH/SOL）作为退款费用，以防止滥用。

如果铸造时使用了 URC 并获得了折扣，已支付给 URC 提供者的奖励将在退款时扣除。

#### 8.1.4 - 退款的优点和效果

- **公平性保证**：
  - 通过退款，后期参与者无需承担过高的铸造成本，确保公平参与。
  - 铸造费用的动态调整与退款共同作用，避免“热铸造”导致的成本激增。
- **防止西比尔攻击**：
  - 由于后期参与者可能发起退款，西比尔攻击者被阻止早期干预。
  - 该机制通过经济激励和约束有效降低恶意行为的概率。
- **社区模拟验证**：
  - 社区内进行的模拟测试显示，退款显著提高了铸造过程的公平性和参与者满意度。
  - 最直接的结果是，由于退款风险，西比尔攻击者减少了恶意活动，进一步优化了生态系统健康。

### 8.2 - 退款并非始终可用

请注意，退款仅在目标 Era 期间可用。在目标 Era 之后，铸造费用将用于初始化流动性池，退款功能将被禁用。

## 9 - 完整案例研究

以下是在 **Solana** 区块链上部署铸造证明（PoM）机制的综合案例研究。

### 9.1 - 参数

- 总供应量：1,000,000,000 代币
- 第 1 个 Era 的每次铸造目标规模 ($M_0$)：10,000 代币
- 第 1 个 Era 的每个 Epoch 目标铸造规模 ($T_0$)：1,000,000 代币
- 每个 Epoch 的最小铸造次数：100
- 目标 Era ($E$)：1，第一个 Era 完成后，持有者可以转移代币并初始化流动性池。
- 每个 Era 的 Epoch 数 ($C$)：250
- 目标铸造天数：30 天
- 减少因子 ($f$)：0.75
- 流动性池的代币百分比 ($r_l$)：10%
- 每次铸造费用 ($P_0$)：2 美元/次铸造（0.0002 美元/代币）
- 每个 Epoch 的目标铸造时间：173 分钟（约 3 小时）
- 初始化流动性池时生成的 LP 代币处理方式：**全部销毁**
- 达到目标 Era #1 时：
  - 总供应量：250,000,000 代币（最大供应量的 25%）
  - 总 Epoch 数：250
  - 铸造次数：>= 25,000
  - 总铸造费用：50,200 美元 至 223,050 美元
  - 初始化流动性池时的价格：0.001807 美元 至 0.008030 美元

### 9.2 - 铸造工作流程（技术上）

![铸造工作流程](https://live.staticflickr.com/65535/54397956567_7e04df4d4b_o.png)

### 9.3 - 初始化流动性池工作流程（技术上）

任何人均可初始化流动性，唯一条件是 Era > 1。

![初始化流动性工作流程](https://live.staticflickr.com/65535/54399022619_193f986fc7_o.png)