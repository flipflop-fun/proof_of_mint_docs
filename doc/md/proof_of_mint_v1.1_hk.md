# 區塊鏈代幣分配嘅新提案：鑄造證明

**作者**：公平啟動實驗室 (F.L.L.)  
**日期**：2024年11月6日  
**版本**：v1.11  

---

### 摘要

公平鑄造（又叫公平啟動）嘅概念喺區塊鏈社群入面越來越受關注，但佢面臨一啲嚴重問題，比如西比爾攻擊、社群共識建立時間唔夠、欺詐同埋缺乏市場價值管理。

本文提出一個新嘅解決方案——鑄造證明（PoM），靈感嚟自比特幣嘅挖礦難度機制。PoM 旨在將哈希算力轉化為鑄造參與度，從而解決公平性問題，減輕西比爾攻擊嘅影響，並為社群共識建立提供充足時間。

建議嘅 PoM 設計用來確保穩定嘅鑄造過程，抑制投機同作弊行為，同時激勵真實用戶。本文詳細分析 PoM 機制，包括計算難度係數同每個 Epoch 鑄造規模嘅核心公式。

本文仲展示咗模擬測試參數同結果，顯示 PoM 喺維持穩定鑄造曲線方面嘅有效性。另外，仲討論咗基於 Era、Epoch 同減少因子嘅總供應量計算，以及預計嘅總鑄造時間。

本文提出咗公平鑄造模式嘅重大進展，提供一個更公平、社群驅動嘅代幣鑄造同分配方法。PoM 有潛力通過確保更公平同可持續嘅鑄造過程，重塑去中心化金融嘅格局。

## 1 - 問題

過去兩年，區塊鏈社群中嘅公平鑄造（或公平啟動）變得極為流行。唔少代幣好快完成咗鑄造過程，隨後喺去中心化交易所上市交易。但係，佢哋嘅價格趨勢通常呈現一個共同模式：喺初始快速上漲後，價格會持續下跌。

經過對唔同公平鑄造平台同項目嘅兩年觀察同研究，我哋發現以下問題：

### 1.1 - 西比爾攻擊

根據相關數據，公平鑄造遊戲中真實參與者嘅比例高達 90%。但超過 95% 嘅代幣由少數精通區塊鏈技術嘅人鑄造。因此，絕大多數普通真實參與者只能獲得好少量嘅代幣。

呢種技術方法通常被稱為“西比爾攻擊”，佢搶走咗公平鑄造嘅“公平性”。少數人以極低成本控制大量代幣，通過快速推高代幣價格然後高價賣出，攞到巨額利潤，呢種做法叫做“拉高出貨”。

### 1.2 - 社群共識建立時間唔夠

社群缺乏足夠時間去建立共識。由於代幣鑄造速度過快，社群仲喺建立共識嘅過程中，價格往往開始下跌，導致社群共識瓦解，最終令社群解散。

### 1.3 - 欺詐

一啲項目嘅成員通過技術手段參與鑄造，製造市場“熱烈”嘅假象，攞到低成本代幣，操縱市場以獲取巨額利潤，將公平鑄造變成欺詐工具。

### 1.4 - 缺乏市場價值管理 (*MVM*)

缺乏有效嘅市場價值管理措施。鑑於鑄造速度極快，通常 100% 嘅代幣喺鑄造完成後直接進入流通，市場價值管理變得至關重要。但公平鑄造代幣嘅“無主”特性需要社群自發組織 MVM。可惜，由於鑄造速度過快，MVM 往往喺代幣價格崩潰前無法及時實施。

### 1.5 - 流動性管理有效嗎？

一啲公平鑄造平台引入咗流動性管理機制，例如喺鑄造過程中收取一定費用，呢啲費用被鎖定喺智能合約入面，喺滿足特定條件（比如達到目標金額或完成所有鑄造）後自動加入去中心化交易所嘅流動性池。

但係，我哋觀察到，喺呢啲項目初始價格快速上漲時，流動性池入面嘅資金佔總流動性池嘅比例好低；而當價格下跌時，流動性池入面嘅資金遠遠唔夠抵擋拋售。

### 1.6 - 時間鎖機制有效嗎？

一啲智能合約引入咗時間鎖機制以防止西比爾攻擊，呢個真可以防止用同一個賬戶進行批量鑄造，但仍然無法阻止用唔同賬戶進行批量鑄造嘅人。

### 1.7 - 內存池同 *MEV*

大多數區塊鏈基於以太坊 EVM，EVM 嘅**內存池**允許大量機械人喺新區塊打包前“窺視”用戶嘅意圖，並率先進行鏈上操作，比如鑄造同交易。我哋觀察到，喺以太坊（區塊打包間隔約 12 秒）同 Arbitrum 等二層網絡（區塊打包間隔約 0.25 秒）上存在大量呢類行為。呢類行為被稱為**最大可提取價值 (MEV)**。據估計，自 2020 年 1 月 1 日起，MEV 總額已超過 7.3 億美元，其中大部分流向咗機械人同礦工。MEV 嘅存在係技術驅動嘅，雖然可以理解，但極大影響咗鏈上操作嘅公平性。

我哋認為，有效防止西比爾攻擊等技術手段同為社群共識建立提供足夠時間，已成為最嚴峻嘅挑戰。雖然好多公平鑄造平台已經意識到呢個問題嘅嚴重性，並試圖採取相應措施防止各種作弊行為，但實際效果好有限。

為咗有效防止西比爾攻擊，一啲平台或項目採用咗**KYC 認證**或依賴項目團隊控制嘅服務器提供**授權簽名**，要求鑄造者持有呢個簽名先可以鑄造。但呢啲方法太過中心化，因此好難被加密社群廣泛接受同支持。

## 2 - 提案

我哋認為，喺現有區塊鏈技術下，完全消除呢啲問題好困難。但一啲新機制可以緩解呢啲問題，增強公平鑄造嘅公平性同建立更好嘅社群。

本文提出以下解決方案：

### 2.1 - 比特幣挖礦難度機制

本提案借鑑咗比特幣挖礦嘅難度機制，所以喺介紹本提案之前，我哋先簡單介紹比特幣挖礦機制。

比特幣挖礦嘅難度機制係比特幣網絡嘅核心部分。佢確保喺去中心化網絡中，鑄造進度以大約每 10 分鐘一個區塊嘅穩定速度進行。呢個機制設計用來適應唔同時間網絡哈希算力嘅變化，目標係無論節點點樣加入網絡，都保持新區塊生成速度嘅相對穩定。

比特幣挖礦難度嘅調整通過一個自動算法實現，大約每兩週（2016 個區塊）調整一次。呢個週期基於比特幣網絡嘅目標區塊生成時間（每 10 分鐘一個區塊）設計。如果過去 2016 個區塊嘅平均生成時間少於 10 分鐘，難度會增加，以確保未來區塊生成時間回復到 10 分鐘。相反，如果平均區塊生成時間多於 10 分鐘，難度會降低。

難度嘅具體計算基於前 2016 個區塊嘅生成時間同目標時間（20160 分鐘，即兩週）嘅比較。難度調整公式根據實際時間同目標時間嘅比率增加或減少難度。呢種調整係連續嘅，以確保比特幣網絡能夠適應不斷變化嘅哈希算力，無論礦工加入或離開，或者高算力挖礦硬件參與。

另外，難度嘅調整仲受到最大變化限制嘅約束，即單次調整嘅難度唔可以超過前次難度嘅 4 倍。呢個係為咗防止難度突然大幅波動影響網絡。

隨住比特幣網絡嘅發展，挖礦難度持續增加，主要係因為參與挖礦嘅哈希算力不斷增長。隨住更多礦工加入網絡同挖礦硬件技術嘅改進，挖礦嘅總算力持續上升，增加咗單個礦工或礦池發現新區塊嘅難度。因此，挖礦難度嘅增加反映咗比特幣網絡哈希算力嘅增長，同時確保比特幣嘅發行速度保持穩定。

比特幣挖礦難度機制係比特幣網絡適應性同穩定性嘅關鍵。佢通過動態調整難度值，確保比特幣區塊嘅生成速度保持喺設計嘅目標水平，同時適應網絡哈希算力嘅變化。

#### 上述難度規則喺比特幣代碼中嘅關鍵代碼（C++ 版本）

```cpp
/* 計算指定區塊索引嘅難度。
 */
double GetDifficulty(const CBlockIndex& blockindex)
{
    int nShift = (blockindex.nBits >> 24) & 0xff;
    double dDiff =
        (double)0x0000ffff / (double)(blockindex.nBits & 0x00ffffff);

    while (nShift < 29)
    {
        dDiff *= 256.0;
        nShift++;
    }
    while (nShift > 29)
    {
        dDiff /= 256.0;
        nShift--;
    }

    return dDiff;
}
```

[比特幣 GitHub 倉庫](https://github.com/bitcoin/bitcoin/blob/1dda1892b6bcc3d4f9678960cc9e9920f491e87e/src/rpc/blockchain.cpp#L87C1-L107C2)

```cpp
unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock, 
  const Consensus::Params& params)
{
    assert(pindexLast != nullptr);
    unsigned int nProofOfWorkLimit = UintToArith256(params.powLimit).GetCompact();

    // 僅喺難度調整間隔時更改
    if ((pindexLast->nHeight+1) % params.DifficultyAdjustmentInterval() != 0)
    {
        if (params.fPowAllowMinDifficultyBlocks)
        {
            // 測試網嘅特別難度規則：
            // 如果新區塊嘅時間戳超過 2*10 分鐘
            // 則允許挖掘最小難度區塊。
            if (pblock->GetBlockTime() > pindexLast->GetBlockTime() + params.nPowTargetSpacing*2)
                return nProofOfWorkLimit;
            else
            {
                // 返回最後一個非特別最小難度規則嘅區塊
                const CBlockIndex* pindex = pindexLast;
                while (pindex->pprev && pindex->nHeight % params.DifficultyAdjustmentInterval() 
                  != 0 && pindex->nBits == nProofOfWorkLimit)
                    pindex = pindex->pprev;
                return pindex->nBits;
            }
        }
        return pindexLast->nBits;
    }

    // 回溯到 14 天前嘅區塊
    int nHeightFirst = pindexLast->nHeight - (params.DifficultyAdjustmentInterval()-1);
    assert(nHeightFirst >= 0);
    const CBlockIndex* pindexFirst = pindexLast->GetAncestor(nHeightFirst);
    assert(pindexFirst);

    return CalculateNextWorkRequired(pindexLast, pindexFirst->GetBlockTime(), params);
}
```

[比特幣 GitHub 倉庫](https://github.com/bitcoin/bitcoin/blob/1dda1892b6bcc3d4f9678960cc9e9920f491e87e/src/pow.cpp#L14)

### 2.2 - 鑄造證明（PoM）

如果我哋將比特幣嘅哈希計算換成鑄造行為，將哈希算力轉化為鑄造參與度，我哋就得到咗我哋提出嘅解決方案，叫做 **鑄造證明**，簡稱 **PoM**。

假設我哋喺以太坊上部署 **PoM**，以太坊已更新為 **權益證明（PoS）** 共識，平均區塊時間約為 **12 秒**。為咗實現鑄造過程嘅穩定性，我哋設計咗以下計劃：

- 整個鑄造過程分為幾個 **Era**，每個 **Era** 包含幾個 **Epoch**。
- 每個 **Epoch** 有一個難度係數（初始 **Epoch** 嘅難度係數為 **1**），由前一個 **Epoch** 嘅實際運行時間決定，並決定當前區塊嘅鑄造規模。
- 每個 Epoch 有幾個鑄造實例；同一 Epoch 嘅每個鑄造實例嘅 **鑄造規模** 相同。
- 每個 **Era** 內嘅 **Epoch** 嘅 **目標鑄造規模** 同 **基礎鑄造規模** 按照固定嘅 **減少因子** 減少。
- 每次鑄造需要固定費用，呢個費用唔會隨 **Era** 同 **Epoch** 嘅鑄造規模減少而改變。

### 2.3 - 示例

#### 2.3.1 - 快速鑄造

喺第 1 個 **Era** 中，**目標鑄造規模** 為 **100,000 代幣**，**基礎鑄造規模** 為 **100 代幣**，**每個 Epoch 嘅目標鑄造時間** 為 **10 分鐘**，鑄造費用為 **0.1 ETH**。

假設喺第 9 個 **Epoch** 中，**100,000 代幣** 喺 400 秒內鑄造完成，**難度係數** 為 **1.015086348**，第 10 個 **Epoch** 用時 200 秒，噉第 10 個 **Epoch** 嘅 **難度係數** 會自動增加到 **1.02185359**，**每次鑄造嘅規模** 會自動減少到 **100 / 1.02185359 = 97.86137759 代幣**，每代幣嘅成本為 **0.1 ETH / 97.86137759 代幣 = 0.001021854 ETH**。

然後，第 11 個 **Epoch** 用時 **1000 分鐘**（超過目標時間 600 秒），所以 **難度係數** 會保持同第 10 個 **Epoch** 相同嘅 **1.02185359**，**每次鑄造嘅規模** 同每代幣嘅成本同第 10 個 **Epoch** 相同。

跟住，第 16 個 **Epoch** 嘅鑄造時間變為 **200 秒**，**難度係數** 會自動增加到 **1.028665947**，**每次鑄造嘅規模** 會減少到 **100 / 1.028665947 = 97.213289 代幣**，每代幣嘅成本為 **0.1 ETH / 97.213289 代幣 = 0.001028666 ETH**，比之前嘅 **Epoch** 高。

以下係解釋上述示例嘅表格：

| Epoch | Epoch 鑄造時間 | 難度係數變化 | 難度係數       | 每次鑄造規模   | 每代幣成本     |
|-------|----------------|--------------|---------------|---------------|---------------|
| 1     | 500            | 0.001666667  | 1.001666667   | 99.83361065   | 0.001001667   |
| 2     | 400            | 0.003333333  | 1.005005556   | 99.50193752   | 0.001005006   |
| 3     | 500            | 0.001666667  | 1.006680565   | 99.3363769    | 0.001006681   |
| 4     | 600            | 0            | 1.006680565   | 99.3363769    | 0.001006681   |
| 5     | 700            | 0            | 1.006680565   | 99.3363769    | 0.001006681   |
| 6     | 800            | 0            | 1.006680565   | 99.3363769    | 0.001006681   |
| 7     | 600            | 0            | 1.006680565   | 99.3363769    | 0.001006681   |
| 8     | 400            | 0.003333333  | 1.010036167   | 99.00635571   | 0.001010036   |
| **9** | 300            | 0.005        | 1.015086348   | 98.51378678   | 0.001015086   |
| **10**| 200            | 0.006666667  | 1.02185359    | 97.86137759   | 0.001021854   |
| **11**| 1000           | 0            | 1.02185359    | 97.86137759   | 0.001021854   |
| 12    | 800            | 0            | 1.02185359    | 97.86137759   | 0.001021854   |
| 13    | 1200           | 0            | 1.02185359    | 97.86137759   | 0.001021854   |
| 14    | 1500           | 0            | 1.02185359    | 97.86137759   | 0.001021854   |
| 15    | 1000           | 0            | 1.02185359    | 97.86137759   | 0.001021854   |
| **16**| 200            | 0.006666667  | 1.028665947   | 97.213289     | 0.001028666   |
| 17    | 800            | 0            | 1.028665947   | 97.213289     | 0.001028666   |
| 18    | 500            | 0.001666667  | 1.03038039    | 97.05153644   | 0.00103038    |
| 19    | 600            | 0            | 1.03038039    | 97.05153644   | 0.00103038    |
| 20    | 500            | 0.001666667  | 1.032097691   | 96.89005302   | 0.001032098   |

上表代幣成本嘅圖表如下：

![代幣成本圖表](https://live.staticflickr.com/65535/54398767960_dd87762ab5_o.png)

#### 2.3.2 - 按目標時間鑄造

如果鑄造太快，鑄造成本會迅速增加。但如果按目標時間鑄造，每個人都會得到相同嘅代幣成本。

以下係解釋嘅表格：

| Epoch | Epoch 鑄造時間 | 難度係數變化 | 難度係數       | 每次鑄造規模   | 每代幣成本     |
|-------|----------------|--------------|---------------|---------------|---------------|
| 1     | 589            | 0.000183333  | 1.000183333   | 99.98167003   | 0.001000183   |
| 2     | 609            | 0            | 1.000183333   | 99.98167003   | 0.001000183   |
| 3     | 596            | 6.66667E-05  | 1.000250012   | 99.97500503   | 0.00100025    |
| 4     | 594            | 0.0001       | 1.000350037   | 99.96500853   | 0.00100035    |
| 5     | 607            | 0            | 1.000350037   | 99.96500853   | 0.00100035    |
| 6     | 609            | 0            | 1.000350037   | 99.96500853   | 0.00100035    |
| 7     | 609            | 0            | 1.000350037   | 99.96500853   | 0.00100035    |
| 8     | 608            | 0            | 1.000350037   | 99.96500853   | 0.00100035    |
| 9     | 604            | 0            | 1.000350037   | 99.96500853   | 0.00100035    |
| 10    | 608            | 0            | 1.000350037   | 99.96500853   | 0.00100035    |
| 11    | 608            | 0            | 1.000350037   | 99.96500853   | 0.00100035    |
| 12    | 607            | 0            | 1.000350037   | 99.96500853   | 0.00100035    |
| 13    | 607            | 0            | 1.000350037   | 99.96500853   | 0.00100035    |
| 14    | 605            | 0            | 1.000350037   | 99.96500853   | 0.00100035    |
| 15    | 603            | 0            | 1.000350037   | 99.96500853   | 0.00100035    |
| 16    | 589            | 0.000183333  | 1.000533435   | 99.94668497   | 0.001000533   |
| 17    | 608            | 0            | 1.000533435   | 99.94668497   | 0.001000533   |
| 18    | 590            | 0.000166667  | 1.00070019    | 99.93002996   | 0.0010007     |
| 19    | 603            | 0            | 1.00070019    | 99.93002996   | 0.0010007     |
| 20    | 611            | 0            | 1.00070019    | 99.93002996   | 0.0010007     |

上表代幣成本嘅圖表如下：

![代幣成本圖表](https://live.staticflickr.com/65535/54398766190_daf48839aa_o.png)

#### 2.3.3 - 關於 Epoch 嘅基礎鑄造規模

另外，**Epoch 嘅基礎鑄造規模** 會逐漸減少。假設 **減少因子** 為 **3/4**：

- 第 1 個 **Era**，**目標鑄造規模** 為 **100,000 代幣**，**基礎鑄造規模** 為 **100 代幣**。
- 第 2 個 **Era**，**目標鑄造規模** 為 **100,000 * 3/4 = 75,000 代幣**，**基礎鑄造規模** 為 **75 代幣**。
- 第 3 個 **Era**，**目標鑄造規模** 為 **75,000 * 3/4 = 56,250 代幣**，**基礎鑄造規模** 為 **56.25 代幣**。
- ...

### 2.4 - 優勢

#### 2.4.1 - 優勢 1

如果 **機械人** 參與鑄造，佢哋會發現鑄造速度越快，攞到嘅代幣越少，成本越高。相反於好多試圖阻止 **機械人** 參與鑄造嘅方法，呢個提案唔阻止機械人進行批量鑄造。但高成本同低收益會令機械人卻步。

#### 2.4.2 - 優勢 2

如果 **機械人** 監控前一個 **Epoch** 嘅鑄造時間去計算下一個 **Epoch** 嘅難度並評估是否參與，噉所有機械人都要擁有自己嘅策略。否則，趨同嘅策略會導致所有機械人擠塞，造成收益顯著下降同成本大幅增加。因為機械人嘅收益唔取決於鑄造嘅“速度”，而更多取決於對其他機械人行為嘅“猜測”，大大增加機械人嘅策略難度。

#### 2.4.3 - 優勢 3

採用難度只增唔減嘅機制，確保預期鑄造成本始終上升。當難度快速增加時，用戶唔會期待難度下降，要唔係繼續鑄造，要唔係停止鑄造。呢個避免咗等待難度下降而導致嘅鑄造停滯。

#### 2.4.4 - 優勢 4

隨住難度同鑄造成本嘅增加，直到市場認為成本達到合理水平，呢時鑄造會減慢或停止。呢時嘅鑄造成本會成為代幣市場價格嘅錨點。

#### 2.4.5 - 優勢 5

從鑄造收集嘅資金用於去中心化交易所嘅流動性池。呢個提案避免咗過去一啲平台收取嘅固定鑄造費用遠遠唔夠滿足市場流動性需求嘅問題。隨住難度嘅增加，每次鑄造嘅產出會減少，完成目標鑄造規模所需嘅鑄造次數會增加，從而提高鑄造費用。增加嘅鑄造費用會被引導到流動性池，提供充足嘅流動性支持市場價值管理。

#### 2.4.6 - 優勢 6

當市場價格下跌時，人哋會發現鑄造不再具成本效益，導致鑄造活動減慢或停止。低成本供應嘅增加會減少或停止，避免價格下跌同代幣供應持續增加嘅“死亡螺旋”陷阱。如果有新礦工加入，難度同成本會再次上升。

#### 2.4.7 - 優勢 7

鑄造成本同難度水平完全取決於市場參與，無中心化控制，喺去中心化環境中實現動態平衡。

> **喺最大利益原則嘅驅動下，最終鑄造速度會趨向目標設定，達到納什均衡。**

呢個機制有效激勵早期參與者，對持續關注嘅社群成員好友好，同時對投機者同通過技術手段作弊嘅人唔友好。

> 我哋已喺以太坊測試網 **Sepolia**（**Solidity**）同 **Solana**（**Rust/Anchor**）開發網上編碼咗 **PoM** 鑄造算法，並會提供前端 **TypeScript** 腳本畀社群測試，同時開源 **Python** 語言模擬代碼。

## 3 - 計算

### 3.1 - 公式

#### 3.1.1 - 當前 Epoch 嘅難度係數

- $d$：難度係數
- $d'$：前一個 Epoch 嘅難度係數
- $\delta d$：難度係數變化
- $N_e$：已過去 Epoch 嘅區塊數
- $N_t$：每個 Epoch 嘅目標區塊數

難度係數嘅變化基於實際時間同目標時間嘅比率計算。我哋只考慮已過去區塊數高於每個 Epoch 目標區塊數嘅情況。公式如下：

$$
\delta d = \frac{1 - \frac{N_e}{N_t}}{100}, \quad (N_e < N_t)
$$

$$
\delta d = 0, \quad (N_e \geq N_t)
$$

**注意**：喺上述公式中，100 係一個用來控制難度增加比例喺一定閾值範圍內嘅因子。將呢個值設為 100 表示難度增加嘅最大比例為 1%。如果將呢個值設為 50，則難度增加嘅最大比例為 2%。

喺得到難度係數變化後，當前 Epoch 嘅難度係數為：

$$
d = d' \cdot (1 + \delta d)
$$

對於可以精確獲取區塊時間戳嘅區塊鏈，上述 **區塊數** 可以換成 **時間戳**。

**示例：**

喺 2.3.1 嘅示例中，每個 **Epoch** 嘅目標鑄造時間為 600 秒。喺 **第 10 個 Epoch**，鑄造用時 200 秒，**第 9 個 Epoch** 嘅 **難度係數** 為 **1.015086348**，所以 **第 10 個 Epoch** 嘅新 **難度係數** 會調整為：**1.015086348 * ((1 - 200 / 600) / 100 + 1) = 1.02185359**。

喺 **第 11 個 Epoch**，鑄造用時 1000 秒，超過目標鑄造時間 600 秒，噉會保持同 **第 10 個 Epoch** 相同嘅 **難度係數** **1.02185359**。

#### 3.1.2 - 當前 Era 嘅每次鑄造基礎規模 ($M_b$)

- $M_b$：當前 Era 嘅每次鑄造基礎規模
- $M_0$：創世 Era 嘅每次鑄造基礎規模
- $f$：減少因子
- $e$：當前 Era

$$
M_b = M_0 \cdot f^{e-1}
$$

**減少因子**

- $f$=0.5 表示每個 Era 減少 **50%**（減半）
- $f$=2/3 表示每個 Era 減少 **33.33%**
- $f$=3/4 表示每個 Era 減少 **25%**
- $f$=4/5 表示每個 Era 減少 **20%**
- $f$=5/6 表示每個 Era 減少 **1/6**，等等。

#### 3.1.3 - 當前 Era 嘅每個 Epoch 目標鑄造規模

- $T$：當前 Era 嘅每個 Epoch 目標鑄造規模
- $T_0$：創世 Era 嘅每個 Epoch 目標鑄造規模
- $f$：減少因子
- $e$：當前 Era

$$
T = T_0 \cdot f^{e-1}
$$

#### 3.1.4 - 當前 Epoch 嘅每次鑄造規模

- $M$：當前 Epoch 嘅每次鑄造規模
- $M_b$：當前 Era 嘅每次鑄造基礎規模
- $d$：難度係數

$$
M = \frac{M_b}{d}
$$

**示例：**

喺 2.3.1 嘅示例中，當前 Era 嘅 **每次鑄造基礎規模** 為 **100 代幣**，**第 16 個 Epoch** 嘅 **難度係數** 為 **1.028665947**，則鑄造規模為：**100 / 1.028665947 = 97.213289 代幣**。

#### 3.1.5

如果 $T$ 唔係 $M$ 嘅整數倍，需要調整 $M$，即：

$$
M_a = \frac{T}{\lfloor \frac{T}{M} \rfloor + 1}, \quad (T \nmid M)
$$

如果 $T$ 係 $M$ 嘅整數倍，則無需如上調整：

$$
M_a = M, \quad (T \mid M)
$$

#### 3.1.6 - 代幣成本

雖然每次鑄造嘅成本保持不變，但隨住難度嘅增加，每次鑄造獲得嘅代幣數量會減少，因此代幣成本會增加。

以下係代幣成本嘅計算方法：

- $P_0$：鑄造費用
- $p$：代幣成本

$$
p = \frac{P_0}{M_a}
$$

如果 **T** 唔係 **M** 嘅整數倍，價格為：

$$
p = \frac{P_0 \cdot (\lfloor \frac{T_0}{M_0} \cdot d \rfloor + 1)}{T_0 \cdot f^{e-1}}, \quad (T \nmid M)
$$

$$
p = \frac{P_0}{M_0 \cdot f^{e-1}} \cdot d, \quad (T \mid M)
$$

由於 $P_0$、$T_0$、$M_0$、$f$ 同 $e$ 喺一個 Era 中係常數，我哋知道：$p \propto d$。

#### 3.1.7

$T$ 同 $M$ 喺每個 **Era** 中呈指數減少，但兩者之間嘅比率保持不變，無論喺邊個 **Era**。

$$
T = T_0 \cdot f^{e-1}
$$

$$
M = \frac{M_b}{d} = \frac{M_0 \cdot f^{e-1}}{d}
$$

$$
\frac{T}{M} = \frac{T_0}{M_0} \cdot d
$$

#### 3.1.8

如果 $N_t$ 設定為 10 分鐘，則每次鑄造嘅理論目標間隔時間為：600 秒 / 33 = 18.18 秒/次。

如果間隔時間較長，意味完成一個 **Epoch** 嘅所有鑄造用時超過計劃（10 分鐘），表明礦工較少，呢時難度降低，每次鑄造嘅獎勵增加。

相反，如果間隔時間較短，表明完成一個 **Epoch** 嘅鑄造用時少於計劃（10 分鐘），表明礦工較多，呢時難度增加，每次鑄造嘅獎勵減少。

### 3.2 - 計算 Epoch 鑄造規模嘅關鍵代碼（Rust）

```rust
pub fn get_mint_size(
  config_data: &TokenConfigData,
) -> Result<(u64, f64, u64)> {
  let delta_difficulty_coefficient = if config_data.mint_state_data.elapsed_seconds_epoch
    < config_data.target_seconds_per_epoch {
    (1.0 - config_data.mint_state_data.elapsed_seconds_epoch.safe_as_f64()? / 
       config_data.target_seconds_per_epoch.safe_as_f64()?) / 100.0
  } else {
    0.0
  };
  let difficulty_coefficient = config_data.mint_state_data.difficulty_coefficient_epoch 
    * (1.0 + delta_difficulty_coefficient);
  let base_mint_size = config_data.initial_mint_size.safe_as_f64()? 
    * config_data.reduce_ratio.powf((config_data.mint_state_data.current_era - 1).safe_as_f64()?);
  let base_target_mint_size_per_epoch = config_data.initial_target_mint_size_per_epoch.safe_as_f64()? 
    * config_data.reduce_ratio.powf((config_data.mint_state_data.current_era - 1).safe_as_f64()?);
  let mint_size =  base_mint_size / difficulty_coefficient;
  let target_mint_size_epoch = (base_target_mint_size_per_epoch / mint_size).trunc() 
  * mint_size;
  Ok((mint_size.safe_as_u64()?, difficulty_coefficient, target_mint_size_epoch.safe_as_u64()?))
}
```

## 4 - 部署參數

### 4.1 - 總供應量

同普通代幣發行模式唔同，**PoM** 嘅 **總供應量** 基於 **Era**、**Epoch** 同 **減少因子** 計算。

決定總供應量嘅四個參數：

- $E$：總 Era 數
- $C$：每個 Era 嘅初始 Epoch 數
- $T_0$：每個 Epoch 嘅初始目標鑄造規模
- $f$：Era 嘅減少因子，$f \in (0,1)$

**計算**

$$
TotalSupply = \sum_{i=1}^{E} (C \cdot T_0 \cdot f^{i-1}) = C \cdot T_0 \cdot \frac{1 - f^E}{1 - f}
$$

**示例：**

$E=15$，$C=10$，$T_0=100,000$ 代幣，$f=0.75$

**總供應量為：** 3,946,546.156 代幣

[點擊此處打開 Wolfram 計算](https://www.wolframalpha.com/input?i=sum+10*100000*0.75%5E%28i-1%29%2C+i+%3D+1+to+15)，您可以用 **Wolfram** 輕鬆計算總供應量。

#### 4.1.1 - 最大總供應量

當 $E$ 趨向無窮大，即鑄造可以無限期繼續，**總供應量** 會收斂到一個值，即：

**計算**

$$
\lim_{E \to \infty} \left( C \cdot T_0 \cdot \frac{1 - f^E}{1 - f} \right) = C \cdot T_0 \cdot \frac{1 - f^{\infty}}{1 - f} = \frac{C \cdot T_0}{1 - f}
$$

**示例：**

$C=10$，$T_0=100,000$ 代幣，$f=0.75$

**總供應量為：** 4,000,000 代幣

### 4.2 - 預計總鑄造時間

**注意：** 實際總鑄造時間會同預計總鑄造時間唔同。

以下係計算預計總鑄造時間嘅公式：

- $E$：Era 數
- $C$：每個 Era 嘅 Epoch 數
- $N_t$：每個 Epoch 嘅目標區塊數
- $t$：每個區塊嘅秒數

**計算**

$$
TotalEstimatedTime = E \cdot C \cdot N_t \cdot t
$$

**示例：**

$E=15$，$C=10$，$N_t=50$，$t=12$ 秒

**預計總鑄造時間：** $15 \cdot 10 \cdot 50 \cdot 12 = 90,000$ 秒 = 25 小時

### 4.3 - 總 Era 數

結合上述兩個公式，我哋可以計算當鑄造咗總供應量 ($r$) 嘅 80% 時，$E_r$（總 Era 數）嘅值。

$$
C \cdot T_0 \cdot \frac{1 - f^{E_r}}{1 - f} = \frac{C \cdot T_0}{1 - f} \cdot r
$$

由此得出：

$$
E_r = \log_f(1 - r)
$$

**示例：**

$r=80\%$，$f=0.75$，則 $E_r = \log_{0.75}(1-0.8) = \frac{\ln 0.2}{\ln 0.75} = 5.59$。

即係喺第 6 個 Era 中期，80% 嘅總供應量會被鑄造。

如果 $C=10$，喺第 56 個 Epoch（$5.59 \cdot 10$）時，80% 嘅總供應量會被鑄造。

### 4.4 - 總鑄造費用

每次鑄造需要固定費用；但由於難度嘅增加，同一 Epoch 內嘅鑄造次數會增加，每次鑄造獲得嘅代幣數量會減少，因此總費用會相應增加。

> **注意：** 呢啲鑄造費用會自動添加到流動性池中。

- $Fee$：總費用
- $P_0$：每次鑄造費用
- $d$：難度係數
- $Q$：一個 Epoch 內嘅鑄造次數
- $T_0$：創世 Era 嘅每個 Epoch 目標鑄造規模
- $M_0$：創世 Era 嘅每次鑄造基礎規模
- $C_e$：已過去嘅 Epoch 數，$C_e = E \cdot C$

一個 Epoch 內嘅鑄造次數：

$$
Q = \lfloor \frac{T_0}{M_0} \cdot d \rfloor + 1, \quad (T_0 \nmid M_0)
$$

$$
Q = \frac{T_0}{M_0} \cdot d, \quad (T_0 \mid M_0)
$$

為簡單起見，假設 $T_0 \mid M_0$，總費用為：

$$
TotalFee = \sum_{i=1}^{C_e} (P_0 \cdot Q_i) = \sum_{i=1}^{C_e} \left( \frac{P_0 \cdot T_0}{M_0} \cdot d_i \right)
$$

由於 $d_i = d_{i-1} \cdot (1 + \delta d_i)$，$\delta d \in [0,0.01]$（見 3.1.1），且 $d_0=1$，總費用範圍為：

$$
TotalFee \in \left[ \frac{P_0 \cdot T_0}{M_0} \cdot \sum_{i=1}^{C_e} 1^i, \frac{P_0 \cdot T_0}{M_0} \cdot 101 \cdot (1.01^{C_e} - 1) \right]
$$

簡化後：

$$
TotalFee \in \left[ \frac{P_0 \cdot T_0}{M_0} \cdot C_e, \frac{P_0 \cdot T_0}{M_0} \cdot 101 \cdot (1.01^{C_e} - 1) \right]
$$

**示例**

$P_0=1$ 美元，$T_0=9000$，$M_0=100$，$d=1.5$，$C_e=300$，最低總費用為 27,000 美元，最高為 169,096.2 美元。

呢個表明如果鑄造很快完成，一個 Epoch 嘅實際鑄造時間 ($N_e$) 小於目標時間 ($N_t$)，會導致難度同鑄造成本持續增加。因此，收集嘅總費用會係難度保持不變時嘅 **6.3** 倍，隨住 Epoch 數量嘅增加，差異會更顯著。

### 4.5 - 使用案例

#### 4.5.1

如果目標總供應量為 2100 萬（大約），可以有（但唔限於）以下參數組合：

| $C$  | $T_0$ | $M_0$ | $f$  | $N_t$ | $t$ | 總供應量       | Era 數 | Epoch 數 | 天數    | 總費用（最低） | 總費用（最高） |
|------|-------|-------|------|-------|-----|---------------|--------|---------|---------|---------------|---------------|
| 600  | 9000  | 1000  | 0.75 | 2000  | 12  | 2160 萬       | 10.413 | 6248    | 1735.56 | 56,241        | 9.088e29      |
| 500  | 11000 | 1000  | 0.75 | 500   | 12  | 2200 萬       | 10.413 | 5206    | 361.57  | 57,277        | 3.49e25       |
| 2500 | 1000  | 100   | 0.75 | 1000  | 0.4 | 1000 萬       | 10.413 | 26032   | 120.5   | 260,320       | 3.15e115      |

**注意：**

- $Eras = \log_f(1-0.95)$，鑄造率為 95%
- $Epochs = Eras \cdot C$
- $days = Epochs \cdot N_t \cdot t / 3600 / 24 = \log_f(1-0.95) \cdot C \cdot N_t \cdot t / 86400$
- 由於 $f$ 同 $t$ 係固定嘅，總天數取決於 $C$ 同 $N_t$

#### 4.5.2 - 如何計算所有參數

我哋會根據以下條件試圖計算所有參數：

- 總供應量：10,000,000
- 總鑄造天數：180 天，鑄造 95% 嘅總供應量
- 目標鑄造費用：30,000 美元
- $f = 0.75$
- $T_0 = 10,000$
- $M_0 = 1,000$
- $t = 0.4$ 秒（適用於 Solana 區塊鏈）

**計算**

1. $\because TotalSupply = C \cdot T_0 / (1-f)$，所以每個 Era 嘅初始 Epoch 數 ($C$) 為：

   $C = TotalSupply \cdot (1 - f) / T_0 = 10,000,000 \cdot (1 - 0.75) / 10000 = 250$

2. 根據以下公式，我哋可以得到 $N_t = 14935$：

   $C \cdot N_t \cdot t \cdot \log_f(1-0.95) = 180 \text{ 天} \cdot 86400 \text{ 秒/天}$

3. 根據以下公式，我哋可以得到 $C_e = 2603$：

   $C_e = Eras \cdot C = \log_f(1-0.95) \cdot C = 10.413 \cdot 250 = 2603$

4. 我哋已知：$T_0=10,000$，$C_e=2603$，$M_0=1000$，最低總費用公式：

   $\frac{P_0 \cdot T_0 \cdot (C_e+1)}{M_0} = P_0 \cdot 10,000 \cdot 2604 / 1000 = 300,000$

   根據最低總費用公式，我哋可以得到 $P_0 = 11.52$ 美元，意味每個代幣嘅最低價格為 $P_0 / M_0 = 11.52 / 1000 = 0.01152$ 美元。

[點擊此處打開在線計算器](https://docs.google.com/spreadsheets/d/1z4eO1k14noxTMcgADMc-I0xFXT0giMFPSBEGal4suvI/edit?usp=sharing)

## 5 - 測試同評估

以下係模擬測試嘅參數：

- 鑄造間隔時間範圍：0-30 秒隨機
- 總 Era 數：10
- 每個 Era 嘅 Epoch 數：20
- 最低難度係數：0.2
- 減少因子：3/4
- 創世 Era 嘅每次鑄造基礎規模：50
- 創世 Era 嘅每個 Epoch 目標鑄造規模：200

### 鑄造獎勵

![鑄造獎勵](https://live.staticflickr.com/65535/54398908259_4b136d9be7_o.png)

**Epoch 實際鑄造收益 vs. 目標鑄造收益**

橙色線條係 **當前 Epoch 嘅實際鑄造規模**，藍色線條表示 **每次鑄造嘅目標鑄造規模**，顯示每個 Era 減少 25% 嘅趨勢。

![Epoch 收益](https://live.staticflickr.com/65535/54398911094_519ec5b9c3_o.png)

**實際鑄造獎勵 vs. 目標鑄造獎勵**

橙色線條係 **實際鑄造規模**，藍色線條係 **目標鑄造規模**。

![鑄造獎勵](https://live.staticflickr.com/65535/54398738141_fc8789af01_o.png)

**總鑄造曲線**

![總鑄造曲線](https://live.staticflickr.com/65535/54094891458_1a1e5df73a_o.png)

**以太坊鏈上嘅模擬結果**

以上係以太坊鏈上嘅模擬結果。

## 6 - 聯盟鑄造計劃

### 6.1 - 描述

**聯盟鑄造計劃**（**AMP**）允許每個用戶生成一個 **唯一推薦碼**（**URC**）同他人分享。當他人用呢個 **URC** 進行鑄造時，佢哋可以得到鑄造費用嘅折扣，推薦人亦可以得到一啲獎勵。**AMP** 設計為去中心化同社群驅動，激勵建立更好嘅社群。

1. **去中心化同社群驅動**
   - 所有鑄造必須用 **URC**，因此每次鑄造都同社群成員相關聯。
   - 鑄造嘅進度同速度受社群成員分享 **URC** 嘅影響，而唔係核心團隊或一啲大戶。
   - 通過 **AMP**，社群可以更容易形成共識同吸引更多成員參與。
2. **激勵社群**
   - 雙重激勵：推薦人（代碼分享者）同用 **URC** 嘅用戶（鑄造者）均可受益，呢種雙重激勵機制有助社群嘅增長同活躍。
3. **鑄造折扣同推薦人獎勵**
   - 鑄造費用折扣同提供 **URC** 嘅賬戶代幣餘額掛鈎。推薦人嘅餘額越多，鑄造折扣越高，鑄造費用越低。呢個鼓勵參與者持有更多代幣而唔係全部賣出。
   - **URC** 分享者可以得到穩定嘅獎勵；呢啲獎勵喺鑄造發生時由鏈上貨幣（以太坊嘅 ETH 或 Solana 嘅 SOL）自動分配到推薦人賬戶。
4. **鑄造費用同難度調整**
   - 動態難度：鑄造嘅總成本同難度會根據社群動態調整；參與鑄造嘅人越多，鑄造速度越快，總鑄造成本越高，額外鑄造費用亦越高。
   - 部分鑄造費用作為折扣重新分配畀鑄造者，作為獎勵分配畀 **URC** 分享者。

$$
ExtraMintFee = \frac{P_0 \cdot T_0}{M_0} \cdot (\sum_{i=0}^{C_e} d_i - C_e - 1)
$$

呢個公式表明，$d_i$ 越高（大約高於 1），額外鑄造費用越高。

由於鑄造費用進入流動性池以支持市場交易，**AMP** 會對社群發展同代幣交易產生積極影響。

### 6.2 - 計算

#### 6.2.1 - 鑄造折扣

折扣由代碼分享者嘅餘額同 **當前** 總供應量嘅比率決定。

- $r$：代碼分享者餘額同 **當前** 總供應量嘅比率。
- $k$：折扣率。

| $r$      | $k$ |
|----------|-----|
| < 0.2%   | 0   |
| 0.2-0.4% | 5%  |
| 0.4-0.6% | 10% |
| 0.6-0.8% | 15% |
| 0.8-1%   | 20% |
| > 1%     | 25% |

#### 6.2.2 - 折扣後嘅鑄造費用

- $Fee$：折扣後嘅鑄造費用
- $P_0$：原始鑄造費用
- $p_0$：第一個 Epoch 鑄造代幣嘅價格
- $p$：折扣前鑄造代幣嘅價格
- $d$：難度係數
- $k$：折扣率

$$
\frac{Fee}{M_b} \cdot d = p_0 + (p - p_0) \cdot (1 - k) = p \cdot (1 - k) + p_0 \cdot k
$$

$$
p = \frac{P_0}{M_b} \cdot d, \quad p_0 = \frac{P_0}{M_b}
$$

從上述等價公式中，我哋可以得到折扣後嘅鑄造費用：

$$
Fee = P_0 \cdot \left(1 + \frac{k}{d} - k\right), \quad (d \geq 1, k \leq 0.25)
$$

$Fee$ 同原始 $P_0$ 嘅餘額為：

$$
P_0 - Fee = P_0 - P_0 \cdot \left(1 + \frac{k}{d} - k\right) = P_0 \cdot k \cdot \left(1 - \frac{1}{d}\right)
$$

折扣率為：

$$
\frac{P_0 - Fee}{P_0} = k \cdot \left(1 - \frac{1}{d}\right)
$$

**示例：**

$P_0=8$ 美元，$d=12.3$，$Token Balance=26,000$，$Total Supply = 5,000,000$ 美元

代幣佔總供應量嘅比率 ($r$) = $26,000 / 5,000,000 = 0.52\%$，所以折扣 ($k$) 為 10%。

實際鑄造費用為：$8 \cdot (1 + 0.1 / 12.3 - 0.1) = 7.265$ 美元

同原始鑄造費用相比，折扣為：$1 - 7.265 / 8 = 9.19\%$

#### 6.2.3 - 唯一推薦碼 (URC)

唯一推薦碼 (URC) 係由分享者嘅賬戶同時間戳生成嘅唯一代碼。

#### 6.2.4 - 鑄造碼嘅限制

- 代碼嘅使用次數唔係無限，默認為 50 次。即係喺用呢個代碼進行 **50** 次鑄造後，代碼會失效，分享者需要重新激活。
- 代碼分享者唔可以隨時重新激活代碼；每次激活之間有間隔時間。默認間隔為 **24 小時**。

#### 6.2.5 - 代碼分享者嘅收益

代碼分享者可以得到鑄造者節省嘅餘額費用嘅 20%。

$$
CodeSharerReward = 0.2 \cdot (P_0 - Fee) = 0.2 \cdot P_0 \cdot k \cdot \left(1 - \frac{1}{d}\right)
$$

難度越高，$k$ 越大，代碼分享者嘅收益越大。

**示例：**

從前述示例，代碼分享者嘅獎勵為：

$0.2 \cdot 8 \cdot 0.10 \cdot (1 - 1/12.3) = 0.147$ 美元

### 6.3 - 評估

我哋試下對鑄造費用嘅公式做一啲更改，睇下佢點樣影響費用：

$$
\frac{MintFee}{P_0} = 1 + \frac{k}{d} - k, \quad (d \geq 1, k \leq 0.25)
$$

#### 6.3.1 - 難度 ($d$) 對鑄造費用嘅影響

根據鑄造費用嘅公式，難度越高，鑄造費用越低，折扣越多。

#### 6.3.2 - $k$ 對鑄造費用嘅影響

根據鑄造費用嘅公式，$k$ 越高，鑄造費用越低，折扣越多。

#### 6.3.3 - 風險

我哋要考慮一種情況，**AMP** 可能會導致自我鑄造（用自己嘅 **URC** 進行鑄造），但我哋相信：一旦一個人擁有一定數量嘅代幣，佢哋會更傾向於建立社群同同他人分享代碼。

另外，即使每個人都用最大折扣進行鑄造（呢個係不可能嘅），最低總鑄造費用會如下：

$$
CodeSharerReward = 0.2 \cdot (P_0 - Fee) = 0.2 \cdot P_0 \cdot k \cdot \left(1 - \frac{1}{d}\right)
$$

因為 $max(k) = 25\%$，當 $d = \infty$ 時，代碼分享者得到 $P_0$ 嘅 5%。

所以，最低總鑄造費用係計劃嘅 95%。考慮到 **AMP** 可能帶來嘅社群活躍度，以及難度嘅增加會提高鑄造費用，呢種減少係值得嘅。

### 6.4 - 初始化

#### 6.4.1 - 系統推薦人

點解需要系統/默認推薦人？

所有鑄造都需要 **URC**。如果有人無法從社群成員處獲得 **URC**，可以用系統提供嘅默認 **URC**。

用默認 **URC** 時，無折扣（因為默認推薦人嘅賬戶餘額為 0）。

### 6.5 - 程序實現

```rust
// 計算費用值同推薦人獎勵
pub fn get_fee_value(fee_rate: u64, difficulty_coefficient: f64, referrer_ata_balance: 
  u64, total_supply: f64) -> (f64, f64) {
  let balance_ratio = referrer_ata_balance as f64 / total_supply;
  let discount_rate = if balance_ratio < 0.002 {0.0}
  else if balance_ratio < 0.004 {0.05}
  else if balance_ratio < 0.006 {0.1}
  else if balance_ratio < 0.008 {0.15}
  else if balance_ratio < 0.01 {0.2}
  else {0.25};
  let fee = fee_rate as f64 * (1.0 + discount_rate / difficulty_coefficient - 
    discount_rate);
  let code_sharer_reward = 0.2 * fee_rate as f64 * discount_rate * (1.0 - 1.0 / 
    difficulty_coefficient);
  (fee as f64, code_sharer_reward)
}
```

### 6.6 - URC 生成同驗證工作流程

為避免機械人監控 URC 代碼嘅生成同更新以進行搶跑，前端同區塊鏈之間僅交換 **URC_Pubkey**。

以下係 Solana 區塊鏈上嘅 URC 生成同驗證工作流程：

![URC 工作流程](https://live.staticflickr.com/65535/54180284230_abee944341_o.png)

## 7 - 流動性

鑄造費用最終會注入去中心化交易所嘅流動性池，交易費用可以喺呢度賺取。

### 7.1 - 流動性池嘅代幣

總代幣供應量嘅一部分會分配到流動性池作為 SOL/代幣對。呢個分配喺鑄造期間分佈到一個專用嘅流動性賬戶。一旦滿足特定條件（例如，第 1 個 Era 完成），呢啲代幣同交易費用（SOL）會自動添加到流動性池。

- $M_a$：每次鑄造嘅代幣數量（見 3.1.4, 3.1.5）
- $r_l$：初始流動性池相對於總發行量嘅比例，$r_l < 1$
- $L$：每次鑄造事件進入流動性專用賬戶嘅代幣數量

$$
L = \frac{M_a \cdot r_l}{1 - r_l}
$$

由於代幣嘅總供應量為：

$$
TotalSupply = \sum_{i=1}^{E} (C \cdot T_0 \cdot \frac{1-f^E}{1-f}) = C \cdot T_0 \cdot \frac{1-f^E}{1-f}
$$

用於初始化流動性池嘅代幣為：

$$
InitLiquidity = TotalSupply \cdot \frac{r_l}{1-r_l} = C \cdot T_0 \cdot r_l \cdot \frac{1-f^E}{(1-f) \cdot (1-r_l)}
$$

### 7.2 - 鑄造費用

鑄造費用喺 6.2.2 節中描述。鑄造費用嘅分配如下：

- URC 提供者：0-5%
- 協議費用：5%
- 流動性池：90-95%

### 7.3 - 初始化流動性池時嘅預計價格

根據去中心化交易所嘅 **AMM**，初始化流動性池時嘅代幣價格為：

$$
Price = \frac{0.90 \cdot TotalFee}{InitLiquidity}
$$

由於總鑄造費用係一個範圍：

$$
TotalFee \in \left[ \frac{P_0 \cdot T_0}{M_0} \cdot C_e, \frac{P_0 \cdot T_0}{M_0} \cdot 101 \cdot (1.01^{C_e} - 1) \right]
$$

所以，初始化流動性池時嘅最低價格為：

$$
P_{low} = \frac{P_0 \cdot C_e \cdot (1-r_l)(1-f)}{M_0 \cdot C \cdot r_l \cdot (1-f^E)} \cdot 0.90
$$

最高價格為：

$$
P_{high} = \frac{101 \cdot P_0 \cdot (1.01^{C_e} - 1)(1-r_l)(1-f)}{M_0 \cdot C \cdot r_l \cdot (1-f^E)} \cdot 0.90 = \frac{101 \cdot (1.01^{C_e} - 1)}{C_e} \cdot P_{low}
$$

喺上述公式中，$C_e = E \cdot C$（$C$ 為每個 Era 嘅 Epoch 數，$E$ 為 Era 數）。

## 8 - 退款

鑄造證明（PoM）係一個根據時間動態調整鑄造規模嘅新代幣發行模型。其關鍵邏輯如下：

- **動態成本調整**：
  - 當實際鑄造時間 **短於目標鑄造時間** 時，鑄造規模減少，代幣成本增加。
  - 當實際鑄造時間 **等於或長於目標鑄造時間** 時，鑄造數量同代幣成本保持不變。
- **激勵機制**：
  - 呢個機制通過成本增加激勵早期參與者，推動鑄造活動。
  - 但係，佢亦可能導致後期參與者嘅成本過高，影響公平性。

### 8.1 - 退款機制嘅引入同設計

為解決上述問題，PoM 引入咗 **退款** 作為輔助約束，以確保公平性同保護參與者。其關鍵點如下：

#### 8.1.1 - 目標 Era 鎖定

喺目標 Era 期間，所有籌集嘅鑄造費用都被鎖定喺一個特殊金庫中，參與者可以隨時發起退款。

#### 8.1.2 - 代幣數量驗證

退款時，系統會驗證用戶錢包中嘅代幣總量是否等於鑄造時嘅數量。

如果用戶已轉移或交易部分代幣，除非喺錢包中補充相應數量嘅代幣，否則退款會失敗。

#### 8.1.3 - 費用扣除規則

退款時，會扣除部分貨幣（例如 ETH/SOL）作為退款費用，以防止濫用。

如果鑄造時用咗 URC 並獲得折扣，已支付畀 URC 提供者嘅獎勵會喺退款時扣除。

#### 8.1.4 - 退款嘅優點同效果

- **公平性保證**：
  - 通過退款，後期參與者唔需要承擔過高嘅鑄造成本，確保公平參與。
  - 鑄造費用嘅動態調整同退款共同作用，避免“熱鑄造”導致嘅成本激增。
- **防止西比爾攻擊**：
  - 由於後期參與者可能發起退款，西比爾攻擊者被阻止早期干預。
  - 呢個機制通過經濟激勵同約束有效降低惡意行為嘅概率。
- **社群模擬驗證**：
  - 社群內進行嘅模擬測試顯示，退款顯著提高咗鑄造過程嘅公平性同參與者滿意度。
  - 最直接嘅結果係，由於退款風險，西比爾攻擊者減少咗惡意活動，進一步優化咗生態系統健康。

### 8.2 - 退款唔係隨時可用

請注意，退款只喺目標 Era 期間可用。喺目標 Era 之後，鑄造費用會用於初始化流動性池，退款功能會被禁用。

## 9 - 完整案例研究

以下係喺 **Solana** 區塊鏈上部署鑄造證明（PoM）機制嘅綜合案例研究。

### 9.1 - 參數

- 總供應量：1,000,000,000 代幣
- 第 1 個 Era 嘅每次鑄造目標規模 ($M_0$)：10,000 代幣
- 第 1 個 Era 嘅每個 Epoch 目標鑄造規模 ($T_0$)：1,000,000 代幣
- 每個 Epoch 嘅最小鑄造次數：100
- 目標 Era ($E$)：1，第一個 Era 完成後，持有人可以轉移代幣同初始化流動性池。
- 每個 Era 嘅 Epoch 數 ($C$)：250
- 目標鑄造天數：30 天
- 減少因子 ($f$)：0.75
- 流動性池嘅代幣百分比 ($r_l$)：10%
- 每次鑄造費用 ($P_0$)：2 美元/次鑄造（0.0002 美元/代幣）
- 每個 Epoch 嘅目標鑄造時間：173 分鐘（約 3 小時）
- 初始化流動性池時生成嘅 LP 代幣處理方式：**全部銷毀**
- 達到目標 Era #1 時：
  - 總供應量：250,000,000 代幣（最大供應量嘅 25%）
  - 總 Epoch 數：250
  - 鑄造次數：>= 25,000
  - 總鑄造費用：50,200 美元 至 223,050 美元
  - 初始化流動性池時嘅價格：0.001807 美元 至 0.008030 美元

### 9.2 - 鑄造工作流程（技術上）

![鑄造工作流程](https://live.staticflickr.com/65535/54397956567_7e04df4d4b_o.png)

### 9.3 - 初始化流動性池工作流程（技術上）

任何人均可初始化流動性，唯一條件係 Era > 1。

![初始化流動性工作流程](https://live.staticflickr.com/65535/54399022619_193f986fc7_o.png)

